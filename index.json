{
	"pages": [
		{"title": "Python", "text": "Python\ntest\nblabla\n", "tags": "", "url": "category/python/index.html"},
		{"title": "Python", "text": "Initiation POO Python\nIntroduction\nPour cette première approche de la programmation objet en Python, nous allons principalement faire de la revue de code et une implémentation naive d&#39;un petit use case. Le but principal de cette première session est de s&#39;inspirer de code existant dans le but de comprendre la logique de développement et la modularité qu&#39;apporte une conception objet. \nRevue de code : Bio.Seq.py\nPour rester proche du monde de la bioinformatique, nous allons regarder le package BioPython et plus particulièrement la classe Seq pour commencer. Le code de cette classe est disponible ici. Comme vous allez très vite le constater cette classe est très grande. Son rôle premier est de stocker des informations de séquence, mais elle est capable de faire plus comme par exemple des traitements de type traduction en proteine. Ces traitements peuvent se faire via des appels à ce que l&#39;on nomme des &quot;méthodes&quot;, ce qui est l&#39;équivalent des &quot;fonctions&quot; pour les modules. Ci-dessous une première extraction du code de la classe.\nBio.Seq.py extract 1\nclass Seq(object):\n    &quot;&quot;&quot;Read-only sequence object (essentially a string with an alphabet).&quot;&quot;&quot;\n    ...\n\n    def __init__(self, data, alphabet=Alphabet.generic_alphabet):\n        &quot;&quot;&quot;Create a Seq object.&quot;&quot;&quot;\n        ...\n\n    def translate(self, table=&quot;Standard&quot;, stop_symbol=&quot;*&quot;, to_stop=False,\n                  cds=False, gap=None):\n        &quot;&quot;&quot;Turn a nucleotide sequence into a protein sequence by creating a new Seq object.&quot;&quot;&quot;\n        ...\nCe que l&#39;on peut d&#39;ores et déjà remarquer, c&#39;est la facilité de compréhension du code. Même sans connaissance a priori de la syntaxe objet Python, on comprend tout de suite, que grace au mot class, on va commencer l&#39;implementation d&#39;une classe qui s&#39;apellera Seq et qui sera construite sur la base d&#39;un type appelé object. La spécification du type object ou non, a une influence seulement sur la version 2 de Python. Sans rentrer dans les détails, ceci permettra d&#39;avoir ou non des classes de nouveau ou de vieux style. Dans le cas de Python 3, toutes les classes sot de nouveau style, il y n&#39;y a donc aucune obligation de spécifié object. Nous reviendrons plus tard sur les types de classes, notamment quand nous aborderons l&#39;héritage.\nNous avons ensuite une méthode __init__, qui comme on peut le supposer sert à l&#39;initiation de la classe. Plus précisement, cette méthode va servir à instancier des objets du type de la classe Seq.\nDe même une classe peut avoir une méthode __del__ qui sera appelé lorsque l&#39;objet sera détruit. Par défaut, il n&#39;est pas souvent nécéssaire d&#39;implementer le destructeur de la classe, mais si vous souhaitez déclencher une action lorsqu&#39;un objet est détruit cela peut être intéressant.\nComme on peut le voir, chaque méthode de la classe a pour premier argument self. Ce mot clef, donné par convention (on pourrait utiliser n&#39;importe quel autre nom), est une référence sur l&#39;objet crée, il faudra donc le spécifier à chaque nouvelle méthode crée.\nPour créer un objet, rien de plus simple. Il suffit que la classe à partir de laquelle on souhaite instancier un objet, soit disponible dans l&#39;espace de nom et pour cela il faut importer la classe. Puis il suffit de déclarer une variable qui sera notre instance et d&#39;appeler la classe avec les attributs nécessaires, ici une chaine de caractère (la notion d&#39;attribut d&#39;objet est abordée dans la section suivante).\nfrom Bio.Seq import Seq\n\nseq = Seq(&quot;ATGTGTAGGATGCGCTCGTAGAGATGCGCT&quot;)\nUne foir l&#39;objet instancié, on peut appeler des méthodes pour faire des traitements.\nprint(seq.translate())\nMCRMRS*RCA\nBio.Seq.py extract 3\nNous avons vu qu&#39;un objet possède des méthodes, qui lui permettent de réaliser des traitements. Un objet possède aussi des variables appelées attributs, qui vont lui permettent de stocker de l&#39;information. Si nous reprenons le code de notre classe, nous voyons qu&#39;un objet Seq à 2 attributs déclarés à l&#39;initialisation: _data et alphabet.\n   def __init__(self, data, alphabet=Alphabet.generic_alphabet):\n        &quot;&quot;&quot;Create a Seq object.\n        Arguments:\n         - seq - Sequence, required (string)\n         - alphabet - Optional argument, an Alphabet object from\n           Bio.Alphabet\n        ...\n        &quot;&quot;&quot;\n\n        self._data = data\n        self.alphabet = alphabet # Seq API requirement \nPour appeler un attribut il suffit de faire:\nseq = Seq(&quot;ATGC&quot;)\nprint(seq.alphabet)\nNous pouvons aussi faire:\nseq = Seq(&quot;ATGC&quot;)\nprint(seq._data)\nMais c&#39;est une très mauvaise pratique à cause du &quot; _ &quot; placé avant le nom de l&#39;attribut. Commencer un nom d&#39;attribut ou de méthode d&#39;un objet par un underscore est une convention de nommage pour spécifier le type &quot;privé&quot;. Nous aborderons ça dans le chapitre suivant.\nBio.Seq.py extract 2\nclass Seq(object):\n    &quot;&quot;&quot;Read-only sequence object (essentially a string with an alphabet).&quot;&quot;&quot;\n    ...\n\n    def __init__(self, data, alphabet=Alphabet.generic_alphabet):\n        &quot;&quot;&quot;Create a Seq object.&quot;&quot;&quot;\n        ...\n\n    def __repr__(self):\n        &quot;&quot;&quot;Return (truncated) representation of the sequence for debugging.&quot;&quot;&quot;\n        ...\n\n    def __str__(self):\n        &quot;&quot;&quot;Return the full sequence as a python string, use str(my_seq).\n        ...\nInteressons nous maintenant aux méthodes particulières qui commencent par 2 underscores et se terminent par 2 underscores. Ces méthodes sont appelés &quot;dunder&quot; ou &quot;méthodes magiques&quot;. Le nom des ces méthodes est réservé par le langage, elles sont appelées dans des conditions particulières. Par exemple, comme nous l&#39;avons déjà vu, la méthode __init__ est appelée à la création d&#39;un objet. Nous avons aussi ici les méthodes __repr__ et __str__ qui ont des fonctions très proches de réprésentation de l&#39;objet dans différentes conditions. Nous ne préciserons pas cela ici, mais il sera intéressant de revenir dessus plus tard. \nAinsi, dans le cas où aucune méthode de réprésentation de l&#39;objet n&#39;est pas implémentée c&#39;est l&#39;adresse mémoire qui est renvoyée.\nseq = Seq(&quot;ATGC&quot;)\nprint(seq)\n\n&lt;Seq.Seq object at 0x7fe8f15b12e8&gt;\nSi on implemente la fonction __str__ de façon à ce quelle retourne sa séquence sous forme de caractères:\n    def __str__(self):\n        &quot;&quot;&quot;Return the full sequence as a python string, use str(my_seq).&quot;&quot;&quot;\n\n        return self.data\nseq = Seq(&quot;ATGC&quot;)\nprint(seq)\n\nATGC\nBio.Seq.py extract 4\nMaintenant si vous souhaitez pouvoir comparer 2 objets Seq, de la même façon que vous comparez 2 nombres, il est nécessaire d&#39;implementer des méthodes particulières dites de &quot;comparaisons riches&quot;. Il y a des astuces pour ne pas avoir à toutes les implémenter, mais je conseille quand même de le faire. En python 3, la méthode __cmp__ n&#39;existe plus, il faut implémenter chaque méthode pour chaque comparaison:\n object.__lt__(self, other) # object1 &lt; object2\n object.__le__(self, other) # object1 &lt;= object2\n object.__eq__(self, other) # object1 == object2  \n object.__ne__(self, other) # object1 != object2\n object.__gt__(self, other) # object1 &gt; object2\n object.__ge__(self, other) # object1 &gt;= object2\n\nSi nous regardons maintenant de plus près l&#39;implémentation de ces méthodes dans l&#39;object Seq:\n    def __eq__(self, other):\n        &quot;&quot;&quot;Compare the sequence to another sequence or a string (README)&quot;&quot;&quot;\n    ....\n        if hasattr(other, &quot;alphabet&quot;):\n            # other could be a Seq or a MutableSeq\n            if not Alphabet._check_type_compatible([self.alphabet,\n                                                    other.alphabet]):\n                warnings.warn(&quot;Incompatible alphabets {0!r} and {1!r}&quot;.format(\n                              self.alphabet, other.alphabet),\n                              BiopythonWarning)\n        return str(self) == str(other)\n\nLa méthode de comparaison va simplement retourner le résultat de la comparaison sous la forme de string de nos 2 objets. On peut néanmoins constater que cette comparaison n&#39;a lieu que si l&#39;objet auquel il est comparé a lui aussi un attribut de type alphabet afin de s&#39;assurer de pouvoir executer la comparaison. De façon plus générale, une bonne pratique d&#39;implémentation de cette méthode est d&#39;envisager par défaut une comparaion impossible entre 2 objets de classes différentes, en retournant la constante (built-in) NotImplemented:\n    def __eq__(self, other):\n        # test class equality\n        if not isinstance(other, type(self):\n            return NotImplemented\n        # return specific comparison\n       ... \n\nPar ailleurs la non-équivalence peut aussi simplement se faire en retournant le résulat inverse de l&#39;équivalence:\n    def __ne__(self,other):\n        return not self == other\n\nFinir\nIl existe un grand nombre de &quot;dunder&quot;, qui une fois implémentés peuvent simplifier la manipulation de vos objets. Une liste complète peut être obtenue ici ou encore ici. Juste pour finir, 2 méthodes implémentées dans la classe Seq: __len__ et __add__.\nLa méthode __len__ est appelé via la fonction len() et est censée renvoyé un nombre:\nseq = Seq(&quot;ATGC&quot;)\nseq.__len__() # 4\n# equals\nlen(seq) # 4\n\nLa méthode __add__ est une méthode arithmétique qui va permettre de pouvoir additionner 2 objets, en retournant un nouvel objet.\nseq1 = Seq(&quot;ATGC&quot;)\nseq1 + seq1\nSeq(&#39;ATGCATGC&#39;, Alphabet())\nseq2 = seq1 + seq1\nseq2\nSeq(&#39;ATGCATGC&#39;, Alphabet())\n\nModélisation UML\nEn parallèle de l&#39;apprentissage de l&#39;objet en Python, je vous propose d&#39;aborder la modélisation objet sous le langage UML. UML signifie &quot;Unified Modeling Language&quot;, pour faire vite, c&#39;est un pseudo-langage sous forme graphique qui propose plusieurs types de diagrammes pour modéliser les structures de données (diagramme de classe, diagramme d&#39;objet, ...) ou les comportements/interactions (diagramme d&#39;activité, diagramme de cas d&#39;utilisation, ...). Dans un premier temps nous nous interesserons seulement au diagramme de classe. L&#39;intérêt de ce genre de diagramme est de proposer une vision au niveau de notre structure de code, sans spécificité de langage. Ainsi un diagramme UML sera valable dans tous les langages, seule l&#39;implementation est spécifique. Un diagramme de classe est un outil très appréciable pour appréhender des modules très complexes et peut aussi vous aider à concevoir vos programmes.\nIl existe de nombreux outils disponibles pour faire de la modélisation UML, vous trouverez une liste ici.\nDans un diagramme de classe, une classe est modélisée par un rectangle divisé en 3 compartiments (cela peut aller jusqu&#39;à 5, mais nous n&#39;aborderons pas cela). On retrouve le nom de classe, puis les attributs et enfin les méthodes (opérations). Voici notre classe Seq:\n\nNous avons 2 attributs, alphabet avec un &quot;+&quot; devant pour signifié qu&#39;il est publique et _data avec un &quot;-&quot; devant pour signifier qu&#39;il est privé. Par souci d&#39;efficacité et de lisibilité, j&#39;ai choisi de ne pas représenter les méthodes &quot;dunder&quot; qui sont propres au langage. Nous n&#39;avons donc vu qu&#39;une seule méthode publique translate qui prend un ensemble d&#39;arguments. Dans ce cas précis, les arguments sont tous optionnels, car des valeurs par défaut sont proposées dans l&#39;implémentation. Nous aurions pu modéliser cela, en rajoutant ces informations sur le diagramme, mais cela aurait complexifier la lecture, ce qui n&#39;est pas le but premier ici. Vous pouvez remarquer aussi que la méthode translate retourne un autre objet Seq. \nImportant: Python est un langage dynamique et permissif dans le sens où, il n&#39;y a pas de véritable mécanisme dans le langage qui empêche d&#39;accéder à n&#39;importe quelle variable. Ainsi comme nous le verrons, définir des attributs ou des méthodes dits &quot;privés&quot; permet de respecter le paradigme objet et se fait par des conventions de nommage.  \nImplementation\nL&#39;exercise consiste à implementer une classe CDS qui possède toute une liste d&#39;attributs (seq,start,end,...) dont une séquence par lien de composition (la séquence du gène est un objet Seq). Cette classe CDS doit pouvoir être utilisée dans des comparaisons et avoir une réprésentation simplifiée. De même, elle possède une méthode de représentation en format bed et peut être traduite en proteine.\nPour vous aider voici une modélisation UML en diagramme de classe de l&#39;implémentation attendue:\nLa solution est ici\nclass Gene(object):\n    &quot;&quot;&quot;Gene class&quot;&quot;&quot;\n\n    def __init__(self, ref, start, end, seq):\n        &quot;&quot;&quot;constructor&quot;&quot;&quot;\n\n        ref=ref\n        start=start\n        end=end\n        seq=Seq(seq)\n\n    def __repr__(self):\n        &quot;&quot;&quot;representation&quot;&quot;&quot;\n\n    def __str__(self):\n        &quot;&quot;&quot;string&quot;&quot;&quot;\n\n    def toBed(self):\n        &quot;&quot;&quot;export in bed format&quot;&quot;&quot;\n\n\n\nL&#39;utilisation d&#39;une classe dans une autre classe se nomme en modélisation, une rélation de composition. Pour être exacte il y a le lien de composition comme ici. C&#39;est à dire que l&#39;object qui est instancié par un autre objet, sera détruit en même temps que l&#39;object instanciateur. En revanche dans le cas d&#39;une relation d&#39;aggregation, un objet se sert d&#39;un autre objet, mais chaque objet est instancié séparement. Ainsi la destruction de l&#39;objet aggregateur n&#39;a pas d&#39;influence sur l&#39;autre objet. Dans le cas de notre classe Gene cela aurait nécessité de construire un objet Seq avant et de fournir cette objet à l&#39;objet Gene. Pour cela nous aurions pu modifier la méthode instanciatrice de l&#39;objet de cette façon:\nclass Gene(object):\n    &quot;&quot;&quot;Gene class&quot;&quot;&quot;\n\n    def __init__(self, ref, start, end, seq):\n        &quot;&quot;&quot;constructor&quot;&quot;&quot;\n\n        ref=ref\n        start=start\n        end=end\n        seq=seq\nInstanciation de l&#39;objet:\nseq = Seq(&quot;ATGTGTAGT&quot;)\ngene = Gene(&quot;seq1&quot;,10,200,seq)\nau lieu de:\ngene = Gene(&quot;seq1&quot;,10,200,&quot;ATGTGTAGT&quot;)\nReferences\nhttps://stackoverflow.com/questions/19861785/composition-and-aggregation-in-python\nhttps://www.programiz.com/python-programming \nhttp://openbookproject.net/thinkcs/python/english3e/index.html#\nhttps://hackernoon.com/understanding-the-underscore-of-python-309d1a029edc\nhttps://www.geeksforgeeks.org/dunder-magic-methods-python/\nhttps://rszalski.github.io/magicmethods/\nhttps://docs.python.org/3/reference/datamodel.html\nUML2: diagramme de classe\n", "tags": "", "url": "category/python/python-s1.html"},
		{"title": "POO Python suite", "text": "POO Python suite\nMaintenant que nous avons abordé la POO par des exemples simples, nous allons pouvoir rajouter quelques notions plus complexes qui mettent en avant l&#39;intérêt de l&#39;approche objet.\nNotion de public, privé, protected et convention de nommage\n", "tags": "", "url": "category/python/python-s2.html"},
		{"title": "Python", "text": "TRICHEUR ! BOUH !\nAlors on rame:\nSilvouplèèèèèè !!! GIF from Sil GIFs\n", "tags": "", "url": "category/python/tricheur.html"},
		{"title": "Accueil", "text": "Welcome!\nSome content 2\n", "tags": "", "url": "index.html"}
	]
}
