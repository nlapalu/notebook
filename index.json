{
	"pages": [
		{"title": ".fai, index de fichier fasta", "text": ".fai, index de fichier fasta\nIntroduction\nUn fichier .fai est un index d&#39;un fichier fasta, décrivant le positionnement de chaque séquence dans le fichier pour permettre une exploitation rapide de son contenu. Ainsi, il sera facile d&#39;extraire rapidement le contenu d&#39;une séquence en utilisant des coordonnées précises.\nContenu\nPour chaque séquence, le fichier contient une ligne avec 5 champs:\n\nle nom de la séquence\nle nombre de base dans la séquence\nindex en bytes de la position de début de la séquence\nnombre de bases par ligne\nnombre de bytes par ligne\n\nPetit rappel sur les bits/bytes/octets ici\nVoici un exemple de fichier fasta et son index .fai associé:\nfasta:\n&gt;seq1\nATGTATGTAGTAGGAT\nATGATGATGATTAGGA\n&gt;seq2\nTGTGATGTGGCTGCTA\nTGTCTATATATATATA\n&gt;seq3\nTTATCTAT\nfai:\nseq1    32    6    16    17\nseq2    32    46    16    17\nseq3    8    86    8    9\nSupperposons les informations de l&#39;index sur le fichier sachant que:\n\nen informatique on compte à partir de 0 (premier index=0)\nle caractère de fin de ligne (\\n) compte un byte. Pour plus de lisibilité on le notera ici: $\n\nVoici le fichier fasta annoté avec les index en bytes:\n 0....5\n &gt;seq1$\n 6...............22\n ATGTATGTAGTAGGAT$\n23...............39\n ATGATGATGATTAGGA$\n40...45\n &gt;seq2$\n46...............62\n TGTGATGTGGCTGCTA$\n63...............79\n TGTCTATATATATATA$\n80....85\n &gt;seq3$\n86.......94\n TTATCTAT$\nOn observe que l&#39;on rerouve facilement les informations décrites dans le fichier d&#39;index. Ainsi le début de la séquence seq2 se fait bien au byte 46 et celui de la seq3 au byte 86. Avec ces points de départ défini, on va pouvoir exploiter le nombre de bases par ligne défini pour chaque séquence pour accéder rapidement à des coordonnées et aux séquences correspondantes. \n", "tags": "", "url": "category/bioinformatics/fai-index-file.html"},
		{"title": "Bioinformatics", "text": "Bioinformatics\ndivers\n", "tags": "", "url": "category/bioinformatics/index.html"},
		{"title": "Other", "text": "Découverte de la bioinformatique\n(stage de collège)\nIntroduction\nQu&#39;est ce que la bioinformatique ? Comme vous pouvez l&#39;entendre c&#39;est le mélange de la bio (biologie) et de l&#39; informatique, ou plutôt de l&#39;informatique spécialisé pour la biologie. L&#39;informatique est maintenant partout, à la maison avec la domotique, dans les banques ou encore dans votre télé. Dans tous les cas il y a de l&#39;informatique mais avec des programmes spécialisés écrits par des gens spécialistes de leur domaine. En bioinformatique on les appelle bionformaticien. Un bioinformaticien a besoin d&#39;avoir des bases en génétique/biologie pour développer des programmes spécifiques. Il faut une bonne compréhension du fonctionnement d&#39;un être vivant, de sa composition et donc de tout de qui tourne autour de l&#39;ADN et des gènes. Qu&#39;est ce que l&#39;ADN ? les gènes ? \nUne petite vidéo explicative sur diverses notions:\n \nUne vidéo sur les notions de séquences d&#39;ADN et de bioinformatique:\n\nMaintenant que les bases de l&#39;ADN et de la notion de séquence d&#39;ADN ont été vues, nous allons réaliser ensemble un petit TP de phylogénie moléculaire. C&#39;est à dire que nous allons récupérer des séquences de génome de différents organismes et grâce à ces séquences nous allons construire une sorte d&#39;arbre. Cet arbre montrera la distance évolutive entre les organismes, c&#39;est à dire &quot;la ressemblance&quot; plus ou moins important des espèces entre elles. On utilise l&#39;image de l&#39;arbre pour montrer l&#39;évolution des espèces les unes par rapport aux autres car il permet de pouvoir positionner chaque espèce comme une feuille d&#39;un arbre et de définir des branches plus ou moins longues selon les ressemblances entre les espèces. \nQuelles sont les étapes que nous allons réaliser ?\n\n1) Explorer des banques de données pour récupérer les séquences de génome de différents organismes\n2) Comparer ces séquences pour extraire les informations identiques et différentes\n3) Utiliser les informations de comparaison pour construire un arbre qui transformera les différences de séquences en branches de différentes longueurs\n\nLes grandes banques de données\nComme vous avez pu le lire, un des aspects de la bioinformatique concerne la creation de grandes banques de données. Cela permet de rendre les données scientifique facilement accessible à tout le monde et pouvoir ainsi centraliser les informations. Pour que cela soit possible, il faut pouvoir disposer de grands centres de stockage de la même façon que vous utilisez des centres de stockage (&quot;datacenter&quot;, &quot;cloud&quot;) pour stocker les photos ou la musique de votre téléphone. Les données biologiques peuvent générer des fichiers très gros, ce qui nécessite beaucoup de place et donc beaucoup d&#39;argent. La gestion de ces grandes banques de données est donc assurée par de grands centres de recherche internationaux qui disposent de très grosses machines. \nIl existe un institut incontournable pour les données biologiques: NCBI (National Center for Biotechnology Information) qui est originellement un institut de medecine américain.  \nLe NCBI abrite la plus grande banque de données internationale concernant les informations genomiques, à savoir les séquences des génomes, les données d&#39;expression des gènes, les protéines, ... Pour explorer cette grande banque de données: ici\nTapez n&#39;importe quel mot (en anglais) et lancer la recherche. Nous allons regarder ensemble les résultats.\nL&#39;alignement de séquence\nNous avons vu qu&#39;il est possible de récupérer facilement des séquences de n&#39;importe quel organisme à partir de mots-clés dans la banque du NCBI.Avec ces séquences nous pouvons réaliser de nombreuses analyses. Une des choses les plus courantes en bioinformatique consiste à regarder la ressemblance des séquences entre elle en réalisant ce que l&#39;on appelle de l&#39;alignement de séquences. Pour cela nous allons utiliser un logiciel qui va permettre de pouvoir mettre en évidence les ressemblances et les différences. \nJe vous propose d&#39;aligner des séquences d&#39;ARN 28S d&#39;Homme, de gorille, d&#39;orang-outan, de rat, de souris et de dingo. Pour information, l&#39;ARN 28S est un élément essentiel pour la construction de ce que l&#39;on appelle les ribosomes. Les ribosomes sont les &quot;usines&quot; à protéines, ce sont eux qui vont permettre de transformer l&#39;expression d&#39;un gène (ARNm) en protéine. Les ribosomes sont donc des éléments très importants et conservés. Ainsi il y a de forte chances que la séquence d&#39;un ARN 28S d&#39;Homme soit proche de celle d&#39;un Gorille.\nRécuperez le fichier sequences.fasta: ici,  qui contient les séquences qui nous intéressent. Vous pouvez regarder le fichier avec un éditeur de texte.\nOuvrez la page du logiciel MultAlin et chargez le fichier select a file: Parcourir.\nPuis lancez le logiciel &quot;Start MultAlin&quot;\nNous allons regarder ensemble les résultats.\nLes arbres phylogénétiques\nNous savons maintenant aligner des séquences de différents organismes et mettre en évidences les parties communes et différentes entre ces séquences. A partir de ces différences nous allons essayer de mettre en évidence la distance évolutive entre ces organismes. C&#39;est à dire que nous allons essayer de déduire quels sont les organismes/espèces les plus proches sur l&#39;arbre des espèces.  En effet, si on suppose que des organismes ou espèces sont proches, il y a de grandes chances que leurs séquences soient plus proches en comparaison avec des espèces éloignées. Par exemple, dans l&#39;exemple que nous étudions, nous pouvons imaginer que la souris est plus proche du rat que de l&#39;Homme. De même on suppose que le Gorille est plus proche de l&#39;Homme que la souris. Pour vérifier cette hypothèse nous allons réaliser un arbre phylogénétique. Grâce à des logiciels qui utilisent les différences entre les séquences nous allons pouvoir établir ce que l&#39;on nomme des distances. Ces distances seront calculées pour toutes les combinaisons d&#39;espèces et nous permettrons de créér des liens plus ou moins long entre chaque espèce.\nPour réaliser cette analyse nous allons utiliser le site phylogenie.fr.\nChoisissez Phylogeny Analysis dans le menu, puis One Click.\nSelectionnez votre fichier sequences.fasta puis lancer l&#39;analyse Submit.  \nVous allez ainsi obtenir un arbre phylogénétique. Quelles sont vos conclusions ?\nSi vous souhaitez explorer l&#39;arbre de la vie avec l&#39;ensemble des oranismes connus, vous pouvez essayer l&#39;application lifemap:\n\nConclusion\nNous avons vu ensemble une application de la bioinformatique: la phylogénie moléculaire. La bioinformatique recouvre bien plus de domaines qui nécéssite chacun des compétences et des connaissances particulières. La bioinformatique est devenue maintenant incontournable pour toute analyse moderne de données biologiques notamment par ce que la quantité de données disponibles augmentent tous les jours et qu&#39;il est impossible de pouvoir analyser ses données sans ordinateur. Il existe de nombreuses formations disponibles en bioinformatique à partir de BAC+3 qui forme à différents domaines. Pour finir vous pouvez lire le témoignage d&#39;un bio-informaticien sur son métier et pour en savoir plus sur les formations qui conduisent à devenir bioinformaticien le lien vers la fiche ONISEP\n", "tags": "", "url": "category/other/bioinfo-college.html"},
		{"title": "Other", "text": "Other\ndivers\n", "tags": "", "url": "category/other/index.html"},
		{"title": "Python", "text": "Python\nateliers Python - version Python 3.7\n", "tags": "", "url": "category/python/index.html"},
		{"title": "Python", "text": "Initiation POO Python\nImplementation - solution\nVoici une proposition d&#39;implementation:\n#!/usr/bin/env python3.7\n\nclass Seq(object):\n\n    def __init__(self, seq, seqType):\n\n        self.seq = seq\n        if seqType not in (&quot;nuc&quot;,&quot;prot&quot;):\n            raise Exception(&quot;Cannot state seqType; nuc or prot&quot;)\n        self.seqType = seqType\n\n    def __str__(self):\n\n        return self.seq \n\n    def __eq__(self, other):\n\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return (str(self) == str(other))\n\n    def __ne__(self, other):\n\n        return not self == other\n\n    def __gt__(self, other):\n\n        if not isinstance(other, type(self)):\n            return NotImplemented\n\n        return (len(self) &gt; len(other))\n\n    def __lt__(self, other):\n\n        return (len(self) &lt; len(other))\n\n    def __len__(self):\n\n        return len(self.seq)\n\n    def rc(self):\n\n        drev = { &#39;A&#39;:&#39;T&#39;,\n                 &#39;a&#39;:&#39;t&#39;,\n                 &#39;T&#39;:&#39;A&#39;,\n                 &#39;t&#39;:&#39;a&#39;,\n                 &#39;G&#39;:&#39;C&#39;,\n                 &#39;g&#39;:&#39;c&#39;,\n                 &#39;C&#39;:&#39;G&#39;,\n                 &#39;c&#39;:&#39;g&#39;}\n\n        return &#39;&#39;.join([drev[i] for i in self.seq[::-1]])\n\n\nclass CDS(object):\n\n    def __init__(self,ref,start,stop,name,seq):\n\n        if (stop-start+1)!= len(seq):\n            raise Exception(&quot;different size for coordinates and seq length&quot;)\n\n        self.ref = ref\n        self.start = start\n        self.stop = stop\n        self.name = name\n        self.seq = Seq(seq,&quot;nuc&quot;)\n\n    def __str__(self):\n\n        return f&quot;CDS: name={self.name},start={self.start},stop={self.stop},ref={self.ref}&quot;\n\n    def __len__(self):\n\n        return len(self.seq)\n\n    def __eq__(self, other):\n\n        return (self.seq == other.seq)\n\n    def __ne__(self, other):\n\n        return not (self == other)\n\n    def __gt__(self, other):\n\n        return (self.seq &gt; other.seq)\n\n    def __lt__(self, other):\n\n        return (self.seq &lt; other.seq)\n\n    def rc(self):\n\n        return self.seq.rc()\n\n    def toBed(self):\n\n        return f&quot;{self.ref}\\t{self.start-1}\\t{self.stop}&quot; \n\n    def toFasta(self, size=60):\n\n        return f&quot;&gt;{self.name}\\n&quot; + &quot;\\n&quot;.join([str(self.seq)[i:i+size] for i in range(0,len(str(self.seq)),size)])\n\n\nif  __name__ == &#39;__main__&#39;:\n\n    cds1 = CDS(&quot;chr1&quot;,20,65,&quot;CDS1&quot;,&quot;ATGAAAAAAAAAATTTTTTTTTTCCCCCCCCCCGGGGGGGGGGGTA&quot;)\n    print(&quot;## cds1 ##&quot;)\n    print(cds1)\n    print(&quot;## cds1.rc() ##&quot;)\n    print(cds1.rc())\n    print(&quot;## cds1.toBed() ##&quot;)\n    print(cds1.toBed())\n    print(&quot;## cds1.toFasta() ##&quot;)\n    print(cds1.toFasta())\n    print(&quot;## cds1.toFasta(5) ##&quot;)\n    print(cds1.toFasta(5))\n    print(&quot;## len(cds1) ##&quot;)\n    print(len(cds1))\n    cds2 = CDS(&quot;chr2&quot;,120,155,&quot;CDS2&quot;,&quot;ATGAAAAAAAAAATTTTTTTTTTCCCCCCCCCCGGG&quot;)\n    print(&quot;## len(cds2) ##&quot;)\n    print(len(cds2))\n    print(&quot;## cds1 != cds2 ##&quot;)\n    print(cds1 != cds2)\n    print(&quot;## cds1 &lt; cds2 ##&quot;)\n    print(cds1 &lt; cds2)\n    print(&quot;## cds1 &gt; cds2 ##&quot;)\n    print(cds1 &gt; cds2)\n    print(&quot;## cds1 == cds2 ##&quot;)\n    print(cds1 == cds2)\n\nL&#39;utilisation d&#39;une classe dans une autre classe se nomme en modélisation, une relation de composition. Pour être exacte il y a le lien de composition comme dans le code ci-dessus et il y a aussi le lien d&#39;aggrégation. Dans le premier cas, un object est instancié par un autre objet, et sera détruit en même temps que l&#39;object instanciateur. Dans le deuxième cas, un objet se sert d&#39;un autre objet, mais chaque objet est instancié séparement. Ainsi la destruction de l&#39;objet aggregateur n&#39;a pas d&#39;influence sur l&#39;autre objet. Dans le cas de notre classe CDS cela aurait nécessité de construire un objet Seq avant et de fournir cet objet à l&#39;objet CDS. Pour cela nous aurions pu modifier la méthode instanciatrice de l&#39;objet de cette façon:\nInstanciation de l&#39;objet:\nclass CDS(object):\n\n    def __init__(self,ref,start,stop,name,seq):\n\n        if (stop-start+1)!= len(seq):\n            raise Exception(&quot;different size for coordinates and seq length&quot;)\n\n        self.ref = ref\n        self.start = start\n        self.stop = stop\n        self.name = name\n        self.seq = seq\n\n...\n\nseq = Seq(&quot;ATGAAAAAAAAAATTTTTTTTTTCCCCCCCCCCGGGGGGGGGGGTA&quot;,&quot;nuc&quot;)\ncds1 = CDS(&quot;chr1&quot;,20,65,&quot;CDS1&quot;,seq)\n\nau lieu de:\nclass CDS(object):\n\n    def __init__(self,ref,start,stop,name,seq):\n\n        if (stop-start+1)!= len(seq):\n            raise Exception(&quot;different size for coordinates and seq length&quot;)\n\n        self.ref = ref\n        self.start = start\n        self.stop = stop\n        self.name = name\n        self.seq = Seq(seq,&quot;nuc&quot;)\n\n...\n\ncds1 = CDS(&quot;chr1&quot;,20,65,&quot;CDS1&quot;,&quot;ATGAAAAAAAAAATTTTTTTTTTCCCCCCCCCCGGGGGGGGGGGTA&quot;)\n\n", "tags": "", "url": "category/python/python-i1.html"},
		{"title": "Python", "text": "Suite POO Python\nImplementation - solution\nVoici une proposition d&#39;implementation:\n#!/usr/bin/env python3.7\n\nclass AbstractFeature(object):\n\n    def __init__(self, seqid, start, end, id):\n\n        if self.__class__.__name__ == &quot;AbstractFeature&quot;:\n            raise Exception(&quot;Cannot instanciate AbstractFeature class, need to be sub-classed&quot;)\n        else:\n            self.seqid=seqid\n            self.start=start\n            self.end=end\n            self.id=id\n\n    def __str__(self):\n\n        return f&quot;{self.__class__.__name__}: {self.seqid}-{self.start}-{self.end}-{self.id}&quot;\n\n    def __len__(self):\n\n        return self.end-self.start+1\n\n    def __add__(self, other):\n\n        # prevent against Gene and Transcript add\n        if self.__class__ != other.__class__:\n            raise Exception(&quot;Cannot sum different AbstractFeature sub-classes&quot;)\n\n        return len(self) + len(other)\n\n    def __radd__(self, other):\n\n        return len(self)  + other\n\n\nclass Gene(AbstractFeature):\n\n    def __init__(self, seqid, start, end, id):\n\n        self.transcripts = []\n        AbstractFeature.__init__(self,seqid, start, end, id)\n\n    def add_transcript(self, mRNA):\n\n        self.transcript.append(mRNA)\n\n\nclass Transcript(AbstractFeature):\n\n     def __init__(self, seqid, start, end, id, gene_id):\n\n        self.gene_id = gene_id\n        AbstractFeature.__init__(self,seqid, start, end, id)\n\n\nclass Stats(object):\n\n    @staticmethod\n    def mean(l):\n\n        return sum(l)/len(l)\n\n\nif __name__ == &quot;__main__&quot;:\n\n    gene1 = Gene(&quot;chr1&quot;, 1000, 2000, &quot;gene1&quot;)\n    mRNA1 = Transcript(&quot;chr1&quot;, 1000, 2000, &quot;mRNA1&quot;, &quot;gene1&quot;)\n    gene2 = Gene(&quot;chr1&quot;, 10000, 12000, &quot;gene2&quot;)\n    mRNA2 = Transcript(&quot;chr1&quot;, 10000, 12000, &quot;mRNA2&quot;, &quot;gene2&quot;)\n    mRNA3 = Transcript(&quot;chr1&quot;, 10000, 11400, &quot;mRNA3&quot;, &quot;gene2&quot;)\n\n    print(gene1+gene2)\n    print(sum((gene1,gene2)))\n    print(f&quot;Gene mean length: {Stats.mean([gene1,gene2])}&quot;)\n    print(f&quot;Transcript mean length: {Stats.mean([mRNA1,mRNA2,mRNA3])}&quot;)\n\nQuelques explications:\n\nl&#39;implementation de __add__ est suffisante quand nous sommons 2 objets du même type. Dans le cas de la fonction sum(), le premier type à sommer est un int, car la première addition est 0 + . Il faut donc implementer &quot;radd&quot;, pour pouvoir résoudre cette première addition.\ndans la méthode __init__() de la classe abstraite, nous implémentons un contôle de type de classe pour éviter l&#39;instanciation de la classe. Cette façon de faire est un peu manuelle, mais nous verrons plus tard qu&#39;il existe des modules dans Python à qui déléguer cette tâche.\ndans la méthode __add__, nous implémentons aussi un contrôle de class pour éviter de pouvoir additionner des sous-classes de type différents. \n\n", "tags": "", "url": "category/python/python-i2.html"},
		{"title": "Python", "text": "Python tester son code pour le rendre plus fiable\nImplementation - solution\nVoici une proposition d&#39;implémentation.\nImplementation du test unittest dans le script test_System.py:\n#!/usr/bin/env python3.7\n\nimport unittest\nimport doctest\n\nfrom System import System\n\nclass TestSystem(unittest.TestCase):\n\n    def setUp(self):\n\n#        print(&quot;Initializing data for tests&quot;)\n        self.sys1 =  System((&quot;reac1&quot;,&quot;reac2&quot;))\n        self.sys2 =  System((&quot;reac1&quot;,&quot;reac3&quot;))\n\n    def tearDown(self):\n\n#        print(&quot;tests finished&quot;)\n        pass\n\n    def test_merge_systems(self):\n\n        expected_sys_merged = System((&quot;reac1&quot;,&quot;reac2&quot;,&quot;reac3&quot;))\n        get_sys_merged = System.merge_systems([self.sys1, self.sys2])\n        self.assertEqual(expected_sys_merged,get_sys_merged)\n\n    def test_count_reactions(self):\n\n        self.assertEqual(2,System.count_reactions([self.sys1]))\n        self.assertEqual(4,System.count_reactions([self.sys1, self.sys2]))\n\n    def load_tests(loader, tests, ignore):\n        &quot;&quot;&quot;run doctest tests&quot;&quot;&quot;\n        tests.addTests(doctest.DocTestSuite(&quot;System&quot;))\n        return tests\n\n\nif __name__ == &quot;__main__&quot;:\n    # add all test from TestCase (starting with test_)\n    suite = unittest.TestLoader().loadTestsFromTestCase(TestSystem)\n    # add tests from load_tests\n    suite.addTests(unittest.TestLoader().loadTestsFromModule(TestSystem))\n    # run the test suite\n    unittest.TextTestRunner(verbosity=2).run(suite)\n\nModification de la Classe System pour intégrer les cas de tests sous forme de doctest plutôt que directement dans le __main__:\n#!/usr/bin/env python3\n\nimport doctest\n\nclass System(object):\n\n    nbSystems = 0\n\n    def __init__(self, reactions=()):\n        &quot;&quot;&quot;Initialize a new System object.\n        &gt;&gt;&gt; syst = System((&quot;reac1&quot;, &quot;reac2&quot;))\n        &gt;&gt;&gt; print(System.nbSystems)\n        1\n        &gt;&gt;&gt; print(sorted(syst.reactions))\n        [&#39;reac1&#39;, &#39;reac2&#39;]\n        &gt;&gt;&gt; syst2 = System((&quot;reac1&quot;, &quot;reac3&quot;))\n        &gt;&gt;&gt; print(System.nbSystems)\n        2\n        &gt;&gt;&gt; print(sorted(syst2.reactions))\n        [&#39;reac1&#39;, &#39;reac3&#39;]\n        &gt;&gt;&gt; syst3 = System.merge_systems([syst,syst2])\n        &gt;&gt;&gt; print(System.nbSystems)\n        3\n        &gt;&gt;&gt; print(sorted(syst3.reactions))\n        [&#39;reac1&#39;, &#39;reac2&#39;, &#39;reac3&#39;]\n        &gt;&gt;&gt; print(System.count_reactions([syst,syst2,syst3]))\n        7\n        &gt;&gt;&gt; System.merge_systems([System((&quot;r1&quot;,&quot;r2&quot;)),System((&quot;r1&quot;,&quot;r3&quot;))]) == System((&quot;r1&quot;,&quot;r2&quot;,&quot;r3&quot;))\n        True\n        &quot;&quot;&quot;\n        self.__reactions = set(reactions)\n        self.__class__.nbSystems += 1\n\n    def __del__(self):\n        self.__class__.nbSystems -= 1\n\n    @property\n    def reactions(self):\n        return self.__reactions\n\n    @reactions.setter\n    def reactions(self, reactions=()):\n        self.__reactions = set(reactions)\n\n    @classmethod\n    def merge_systems(cls,systems=[]):\n        &quot;&quot;&quot;Merge system from a list of Systems\n        &quot;&quot;&quot;\n\n        lreactions = []\n        for sys in systems:\n            lreactions.extend(sys.reactions)\n\n        return cls(set(lreactions))\n\n    @staticmethod\n    def count_reactions(systems=[]):\n\n        return sum([len(syst.reactions) for syst in systems])\n\n    def __eq__(self, other):\n\n        return self.__reactions == other.__reactions\n\n    def __repr__(self):\n\n        return repr(self.reactions)\n\nif __name__ == &quot;__main__&quot;:\n\n   doctest.testmod()\n\nPour tester les doctest:\npython3.7 -m doctest System.py -v ou python3.7 System.py -v\nPour tester les tests unittest et la doctest:\npython3.7 test_System.py -v\n\ntest_count_reactions (__main__.TestSystem) ... ok\ntest_merge_systems (__main__.TestSystem) ... ok\n__init__ (System.System)\nDoctest: System.System.__init__ ... ok\n\n----------------------------------------------------------------------\nRan 3 tests in 0.004s\n\nOK\n", "tags": "", "url": "category/python/python-i3.html"},
		{"title": "Python", "text": "Initiation POO Python\nIntroduction\nPour cette première approche de la programmation objet en Python, nous allons principalement faire de la revue de code et une implémentation naive d&#39;un petit use case. Le but principal de cette première session est de s&#39;inspirer de code existant dans le but de comprendre la logique de développement et la modularité qu&#39;apporte une conception objet. \nRevue de code : Bio.Seq.py\nPour rester proche du monde de la bioinformatique, nous allons regarder le package BioPython et plus particulièrement la classe Seq pour commencer. Le code de cette classe est disponible ici. Comme vous allez très vite le constater cette classe est très grande. Son rôle premier est de stocker des informations de séquence, mais elle est capable de faire plus comme par exemple des traitements de type traduction en proteine. Ces traitements peuvent se faire via des appels à ce que l&#39;on nomme des &quot;méthodes&quot;, ce qui est l&#39;équivalent des &quot;fonctions&quot; pour les modules. Ci-dessous une première extraction du code de la classe.\nBio.Seq.py - extrait 1\nclass Seq(object):\n    &quot;&quot;&quot;Read-only sequence object (essentially a string with an alphabet).&quot;&quot;&quot;\n    ...\n\n    def __init__(self, data, alphabet=Alphabet.generic_alphabet):\n        &quot;&quot;&quot;Create a Seq object.&quot;&quot;&quot;\n        ...\n\n    def translate(self, table=&quot;Standard&quot;, stop_symbol=&quot;*&quot;, to_stop=False,\n                  cds=False, gap=None):\n        &quot;&quot;&quot;Turn a nucleotide sequence into a protein sequence by creating a new Seq object.&quot;&quot;&quot;\n        ...\nCe que l&#39;on peut d&#39;ores et déjà remarquer, c&#39;est la facilité de compréhension du code. Même sans connaissance a priori de la syntaxe objet Python, on comprend tout de suite, que grace au mot class, on va commencer l&#39;implementation d&#39;une classe qui s&#39;apellera Seq et qui sera construite sur la base d&#39;un type appelé object. La spécification du type object ou non, a une influence seulement sur la version 2 de Python. Sans rentrer dans les détails, ceci permettra d&#39;avoir ou non des classes de nouveau ou de vieux style. Dans le cas de Python 3, toutes les classes sont de nouveau style, il y n&#39;y a donc aucune obligation de spécifié object. Nous reviendrons plus tard sur les types de classes, notamment quand nous aborderons l&#39;héritage.\nNous avons ensuite une méthode __init__, qui comme on peut le supposer sert à l&#39;initiation de la classe. Plus précisement, cette méthode va servir à instancier des objets du type de la classe Seq.\nDe même une classe peut avoir une méthode __del__ qui sera appelée lorsque l&#39;objet sera détruit. Par défaut, il n&#39;est pas souvent nécéssaire d&#39;implementer le destructeur de la classe, mais si vous souhaitez déclencher une action lorsqu&#39;un objet est détruit cela peut être intéressant.\nComme on peut le voir, chaque méthode de la classe a pour premier argument self. Ce mot clef, donné par convention (on pourrait utiliser n&#39;importe quel autre nom), est une référence sur l&#39;objet créé, il faudra donc le spécifier à chaque nouvelle méthode créée.\nPour créer un objet, rien de plus simple. Il suffit que la classe à partir de laquelle on souhaite instancier un objet, soit disponible dans l&#39;espace de nom et pour cela il faut importer la classe. Puis il suffit de déclarer une variable qui sera notre instance et d&#39;appeler la classe avec les attributs nécessaires, ici une chaine de caractère (la notion d&#39;attribut d&#39;objet est abordée dans la section suivante).\nfrom Bio.Seq import Seq\n\nseq = Seq(&quot;ATGTGTAGGATGCGCTCGTAGAGATGCGCT&quot;)\nUne foir l&#39;objet instancié, on peut appeler des méthodes pour faire des traitements. Syntaxe: &quot;instance de l&#39;objet&quot;.&quot;nom de la méthode()&quot;\nprint(seq.translate())\nMCRMRS*RCA\nBio.Seq.py - extrait 2\nNous avons vu qu&#39;un objet possède des méthodes, qui lui permettent de réaliser des traitements. Un objet possède aussi des variables appelées attributs, qui vont lui permettent de stocker de l&#39;information. Si nous reprenons le code de notre classe, nous voyons qu&#39;un objet Seq à 2 attributs déclarés à l&#39;initialisation: _data et alphabet.\n   def __init__(self, data, alphabet=Alphabet.generic_alphabet):\n        &quot;&quot;&quot;Create a Seq object.\n        Arguments:\n         - seq - Sequence, required (string)\n         - alphabet - Optional argument, an Alphabet object from\n           Bio.Alphabet\n        ...\n        &quot;&quot;&quot;\n\n        self._data = data\n        self.alphabet = alphabet # Seq API requirement \nPour appeler un attribut il suffit de faire: &quot;instance de l&#39;objet&quot;.&quot;nom de l&#39;attribut&quot;\nseq = Seq(&quot;ATGC&quot;)\nprint(seq.alphabet)\n\nNous pouvons aussi faire:\nseq = Seq(&quot;ATGC&quot;)\nprint(seq._data)\n\nMais c&#39;est une très mauvaise pratique à cause du &quot; _ &quot; placé avant le nom de l&#39;attribut. Commencer un nom d&#39;attribut ou de méthode d&#39;un objet par un underscore est une convention de nommage pour spécifier le type &quot;privé&quot;. Nous aborderons ça dans le chapitre suivant.\nBio.Seq.py - extrait 3\nclass Seq(object):\n    &quot;&quot;&quot;Read-only sequence object (essentially a string with an alphabet).&quot;&quot;&quot;\n    ...\n\n    def __init__(self, data, alphabet=Alphabet.generic_alphabet):\n        &quot;&quot;&quot;Create a Seq object.&quot;&quot;&quot;\n        ...\n\n    def __repr__(self):\n        &quot;&quot;&quot;Return (truncated) representation of the sequence for debugging.&quot;&quot;&quot;\n        ...\n\n    def __str__(self):\n        &quot;&quot;&quot;Return the full sequence as a python string, use str(my_seq).\n        ...\n\nInteressons nous maintenant aux méthodes particulières qui commencent par 2 underscores et se terminent par 2 underscores. Ces méthodes sont appelés &quot;dunder&quot; ou &quot;méthodes magiques&quot;. Le nom des ces méthodes est réservé par le langage, elles sont appelées dans des conditions particulières. Par exemple, comme nous l&#39;avons déjà vu, la méthode __init__ est appelée à la création d&#39;un objet. Nous avons aussi ici les méthodes __repr__ et __str__ qui ont des fonctions très proches de réprésentation de l&#39;objet dans différentes conditions. Nous ne préciserons pas cela ici, mais il sera intéressant de revenir dessus plus tard. \nAinsi, dans le cas où aucune méthode de réprésentation de l&#39;objet n&#39;est pas implémentée c&#39;est l&#39;adresse mémoire qui est renvoyée.\nseq = Seq(&quot;ATGC&quot;)\nprint(seq)\n\n&lt;Seq.Seq object at 0x7fe8f15b12e8&gt;\n\nSi on implemente la fonction __str__ de façon à ce quelle retourne sa séquence sous forme de caractères:\n    def __str__(self):\n        &quot;&quot;&quot;Return the full sequence as a python string, use str(my_seq).&quot;&quot;&quot;\n\n        return self.data\n\nseq = Seq(&quot;ATGC&quot;)\nprint(seq)\n\nATGC\nBio.Seq.py - extrait 4\nMaintenant si vous souhaitez pouvoir comparer 2 objets Seq, de la même façon que vous comparez 2 nombres, il est nécessaire d&#39;implementer des méthodes particulières dites de &quot;comparaisons riches&quot;. Il y a des astuces pour ne pas avoir à toutes les implémenter, mais je conseille quand même de le faire. En python 3, la méthode __cmp__ n&#39;existe plus, il faut implémenter chaque méthode pour chaque comparaison:\n object.__lt__(self, other) # object1 &lt; object2\n object.__le__(self, other) # object1 &lt;= object2\n object.__eq__(self, other) # object1 == object2  \n object.__ne__(self, other) # object1 != object2\n object.__gt__(self, other) # object1 &gt; object2\n object.__ge__(self, other) # object1 &gt;= object2\n\nSi nous regardons maintenant de plus près l&#39;implémentation de ces méthodes dans l&#39;object Seq:\n    def __eq__(self, other):\n        &quot;&quot;&quot;Compare the sequence to another sequence or a string (README)&quot;&quot;&quot;\n    ....\n        if hasattr(other, &quot;alphabet&quot;):\n            # other could be a Seq or a MutableSeq\n            if not Alphabet._check_type_compatible([self.alphabet,\n                                                    other.alphabet]):\n                warnings.warn(&quot;Incompatible alphabets {0!r} and {1!r}&quot;.format(\n                              self.alphabet, other.alphabet),\n                              BiopythonWarning)\n        return str(self) == str(other)\n\nLa méthode de comparaison va simplement retourner le résultat de la comparaison sous la forme de string de nos 2 objets. On peut néanmoins constater que cette comparaison n&#39;a lieu que si l&#39;objet auquel il est comparé a lui aussi un attribut de type alphabet afin de s&#39;assurer de pouvoir executer la comparaison. De façon plus générale, une bonne pratique d&#39;implémentation de cette méthode est d&#39;envisager par défaut une comparaion impossible entre 2 objets de classes différentes, en retournant la constante (built-in) NotImplemented:\n    def __eq__(self, other):\n        # test class equality\n        if not isinstance(other, type(self):\n            return NotImplemented\n        # return specific comparison\n       ... \n\nPar ailleurs la non-équivalence peut aussi simplement se faire en retournant le résulat inverse de l&#39;équivalence:\n    def __ne__(self,other):\n        return not self == other\n\nIl existe un grand nombre de &quot;dunder&quot;, qui une fois implémentés peuvent simplifier la manipulation de vos objets. Une liste complète peut être obtenue ici ou encore ici. \nJuste pour finir, voyons 2 méthodes implémentées dans la classe Seq: __len__ et __add__.\nLa méthode __len__ est appelé via la fonction len() et est censée renvoyé un nombre:\nseq = Seq(&quot;ATGC&quot;)\nseq.__len__() # 4\n# equals\nlen(seq) # 4\n\nLa méthode __add__ est une méthode arithmétique qui va permettre de pouvoir additionner 2 objets, en retournant un nouvel objet.\nseq1 = Seq(&quot;ATGC&quot;)\nseq1 + seq1\nSeq(&#39;ATGCATGC&#39;, Alphabet())\nseq2 = seq1 + seq1\nseq2\nSeq(&#39;ATGCATGC&#39;, Alphabet())\n\nIl est important de retenir qu&#39;un grand nombre d&#39;opération sont possibles sur les objets à travers de méthodes &#39;built-in&#39; qu&#39;il suffit d&#39;implémenter. Il n&#39;est donc pas forcémment nécéssaire de créer de nouvelles méthodes, il suffit d&#39;implementer les bonnes.\nModélisation UML\nEn parallèle de l&#39;apprentissage de l&#39;objet en Python, je vous propose d&#39;aborder la modélisation objet sous le langage UML(&quot;Unified Modeling Language&quot;). Pour faire vite, c&#39;est un pseudo-langage sous forme graphique qui propose plusieurs types de diagrammes pour modéliser les structures de données (diagramme de classe, diagramme d&#39;objet, ...) ou les comportements/interactions (diagramme d&#39;activité, diagramme de cas d&#39;utilisation, ...). Dans un premier temps nous nous intéresserons seulement au diagramme de classe. L&#39;intérêt de ce genre de diagramme est de proposer une vision au niveau de notre structure de code, sans spécificité de langage. Ainsi un diagramme UML sera valable dans tous les langages, seule l&#39;implementation est spécifique. Un diagramme de classe est un outil très appréciable pour appréhender des modules très complexes et peut aussi vous aider à concevoir vos programmes.\nIl existe de nombreux outils disponibles pour faire de la modélisation UML, vous trouverez une liste ici.\nDans un diagramme de classe, une classe est modélisée par un rectangle divisé en 3 compartiments (cela peut aller jusqu&#39;à 5, mais nous n&#39;aborderons pas cela). On retrouve le nom de classe, puis les attributs et enfin les méthodes (opérations). Voici notre classe Seq:\n\nNous avons 2 attributs, alphabet avec un &quot;+&quot; devant pour signifier qu&#39;il est publique et _data avec un &quot;-&quot; devant pour signifier qu&#39;il est privé. Par souci d&#39;efficacité et de lisibilité, j&#39;ai choisi de ne pas représenter les méthodes &quot;dunder&quot; qui sont propres au langage. Nous n&#39;avons donc vu qu&#39;une seule méthode publique translate qui prend un ensemble d&#39;arguments. Dans ce cas précis, les arguments sont tous optionnels, car des valeurs par défaut sont proposées dans l&#39;implémentation. Nous aurions pu modéliser cela, en rajoutant ces informations sur le diagramme, mais cela aurait complexifier la lecture, ce qui n&#39;est pas le but premier ici. Vous pouvez remarquer aussi que la méthode translate retourne un autre objet Seq. \nImportant: Python est un langage dynamique et permissif dans le sens où, il n&#39;y a pas de véritable mécanisme dans le langage qui empêche d&#39;accéder à n&#39;importe quelle variable. Ainsi comme nous le verrons, définir des attributs ou des méthodes dits &quot;privés&quot; permet de respecter le paradigme objet et se fait par des conventions de nommage.  \nImplementation\nL&#39;exercise consiste à implementer une classe CDS qui possède toute une liste d&#39;attributs (seq,start,end,...) dont une séquence par lien de composition (la séquence du gène est un objet Seq). Cette classe CDS doit pouvoir être utilisée dans des comparaisons et avoir une réprésentation simplifiée. De même, elle possède une méthode de représentation en format fasta, bed et peut être reverse-complémentée.\nPour vous aider voici une modélisation UML en diagramme de classe de l&#39;implémentation attendue:\n\nImplementez les 2 classes dans le même fichier et rajoutez le code suivant, à la suite des 2 classes.\nif  __name__ == &#39;__main__&#39;:\n\n    cds1 = CDS(&quot;chr1&quot;,20,65,&quot;CDS1&quot;,&quot;ATGAAAAAAAAAATTTTTTTTTTCCCCCCCCCCGGGGGGGGGGGTA&quot;)\n    print(&quot;## cds1 ##&quot;)\n    print(cds1)\n    print(&quot;## cds1.rc() ##&quot;)\n    print(cds1.rc())\n    print(&quot;## cds1.toBed() ##&quot;)\n    print(cds1.toBed())\n    print(&quot;## cds1.toFasta() ##&quot;)\n    print(cds1.toFasta())\n    print(&quot;## cds1.toFasta(5) ##&quot;)\n    print(cds1.toFasta(5))\n    print(&quot;## len(cds1) ##&quot;)\n    print(len(cds1))\n    cds2 = CDS(&quot;chr2&quot;,120,155,&quot;CDS2&quot;,&quot;ATGAAAAAAAAAATTTTTTTTTTCCCCCCCCCCGGG&quot;)\n    print(&quot;## len(cds2) ##&quot;)\n    print(len(cds2))\n    print(&quot;## cds1 != cds2 ##&quot;)\n    print(cds1 != cds2)\n    print(&quot;## cds1 &lt; cds2 ##&quot;)\n    print(cds1 &lt; cds2)\n    print(&quot;## cds1 &gt; cds2 ##&quot;)\n    print(cds1 &gt; cds2)\n    print(&quot;## cds1 == cds2 ##&quot;)\n    print(cds1 == cds2)\n\nExecutez le script, voici le résultat que vous devez obtenir:\n## cds1 ##\nCDS: name=CDS1,start=20,stop=65,ref=chr1\n## cds1.rc() ##\nTACCCCCCCCCCCGGGGGGGGGGAAAAAAAAAATTTTTTTTTTCAT\n## cds1.toBed() ##\nchr1    19      65\n## cds1.toFasta() ##\n&gt;CDS1\nATGAAAAAAAAAATTTTTTTTTTCCCCCCCCCCGGGGGGGGGGGTA\n## cds1.toFasta(5) ##\n&gt;CDS1\nATGAA\nAAAAA\nAAATT\nTTTTT\nTTTCC\nCCCCC\nCCCGG\nGGGGG\nGGGGT\nA\n## len(cds1) ##\n46\n## len(cds2) ##\n36\n## cds1 != cds2 ##\nTrue\n## cds1 &lt; cds2 ##\nFalse\n## cds1 &gt; cds2 ##\nTrue\n## cds1 == cds2 ##\nFalse\nLa solution est ici\nRetour sur l&#39;atelier\nDans cet atelier nous avons abordé:\n\nle concept de programmation objet sous Python.\nla notion d&#39;attribut et de méthode (publiques)\nles méthodes magiques ou &quot;dunder&quot;\nle concept de modélisation UML\n\nRéferences\nQuelques liens intéressants qui ont servi à faire cet atelier:\n\nhttps://www.programiz.com/python-programming \nhttp://openbookproject.net/thinkcs/python/english3e/index.html#\nhttps://hackernoon.com/understanding-the-underscore-of-python-309d1a029edc\nhttps://www.geeksforgeeks.org/dunder-magic-methods-python/\nmagic methods\nmagic methods\nUML2: diagramme de classe\nhttps://stackoverflow.com/questions/19861785/composition-and-aggregation-in-python\n\n", "tags": "", "url": "category/python/python-s1.html"},
		{"title": "POO Python suite", "text": "POO Python suite\nIntroduction\nMaintenant que nous avons abordé la POO par des exemples simples, nous allons pouvoir rajouter quelques notions plus complexes qui mettent en avant l&#39;intérêt de l&#39;approche objet. De la même façon que pour l&#39;atelier précédent, nous allons extraire du code de logiciel, qui nous servira de support au explication. \nEncapsulation: public, privé, protected et convention de nommage\nNous allons tout d&#39;abord aborder la notion d&#39;encapsulation, qui repose sur le fait d&#39;authoriser l&#39;accès à des attributs ou des méthodes dans des situations particulières. Ainsi, un attribut de type privé ne sera accessible que par la classe qui possède l&#39;attribut, dans le cas de protégé l&#39;attribut sera aussi accessible par les classes filles (héritage) et dans le cas publique, il n&#39;y a pas de restriction. En python pour différencier les 3 types on utilise les _. Ainsi on ajoute 2 _ pour le type privé, 1 _ pour protégé. Il n&#39;y a rien à faire dans le cas publique.\nDans le cas de Python, il est important de comprendre que l&#39;encapsulation n&#39;est pas quelque-chose d&#39;important par rapport à l&#39;esprit du langage qui se veut simple. Ainsi, il n&#39;y a pas de mécanisme fort d&#39;encapsulation, ni de pratique commune, chacun peux implementer des fonctionnements différents.\nVoici un exemple d&#39;une classe Network de la biopython (ici). Nous allons utiliser ce code pour visualiser différents mécanismes possibles.\nImplementation initiale:\nclass System(object):\n    &quot;&quot;&quot;Abstraction for a collection of reactions.\n    This class is used in the Bio.Pathway framework to represent an arbitrary\n    collection of reactions without explicitly defined links.\n    Attributes:\n     - None\n    &quot;&quot;&quot;\n\n    def __init__(self, reactions=()):\n        &quot;&quot;&quot;Initialize a new System object.&quot;&quot;&quot;\n        self.__reactions = set(reactions)\n\n    def __repr__(self):\n        &quot;&quot;&quot;Return a debugging string representation of self.&quot;&quot;&quot;\n        return &quot;System(&quot; + &quot;,&quot;.join(map(repr, self.__reactions)) + &quot;)&quot;\n\n    def __str__(self):\n        &quot;&quot;&quot;Return a string representation of self.&quot;&quot;&quot;\n        return &quot;System of &quot; + str(len(self.__reactions)) + \\\n               &quot; reactions involving &quot; + str(len(self.species())) + \\\n               &quot; species&quot;\n\n    def add_reaction(self, reaction):\n        &quot;&quot;&quot;Add reaction to self.&quot;&quot;&quot;\n        self.__reactions.add(reaction)\n\n    def remove_reaction(self, reaction):\n        &quot;&quot;&quot;Remove reaction from self.&quot;&quot;&quot;\n        self.__reactions.remove(reaction)\n\n    def reactions(self):\n        &quot;&quot;&quot;Return a list of the reactions in this system.\n        Note the order is arbitrary!\n        &quot;&quot;&quot;\n        # TODO - Define __lt__ so that Reactions can be sorted on Python?\n        return list(self.__reactions)\n\nAinsi, si vous appelez directement l&#39;attribut privé __reactions, vous obtenez une erreur:\nfrom Bio.Pathway import System, Reaction\n\nreac1 = Reaction()\nreac2 = Reaction()\nsyst = System((reac1, reac2))\nprint(syst.__reactions)\n\nTraceback (most recent call last):\n  File &quot;./python-s2-implementation.py&quot;, line 8, in &lt;module&gt;\n    print(syst.__reactions)\nAttributeError: &#39;System&#39; object has no attribute &#39;__reactions&#39; \n\nVous êtes obligés, d&#39;utiliser la méthode d&#39;accès proposée: reactions()\nprint(syst.reactions())\n\n[Reaction({},[],None,0)]\n\nMais il faut savoir que Python triche, il renomme simplement l&#39;attribut de façon à le masquer. Il reste accessible avec cette petite astuce:\n# ref instance._Class__nameAttribute\nprint(syst._System__reactions)\n\nset([Reaction({},[],None,0)])\n\nImplementation avec accesseurs\nNous allons faire une implementation basique avec nos propres accesseurs (=mutators)\nclass System(object):\n\n    def __init__(self, reactions=()):\n        &quot;&quot;&quot;Initialize a new System object.&quot;&quot;&quot;\n        self.__reactions = set(reactions)\n\n    def get_reactions(self):\n        return self.__reactions\n\n    def set_reactions(self, reactions):\n        self.__reactions = set(reactions)\n\nImplementation avec accesseurs dunder\nNous allons remplacer nos accesseurs &quot;maison&quot; par des méthodes dunder. Cette implementation qui n&#39;a pas vraiement d&#39;intérêt, permet de comprendre que l&#39;accès ou la modification des valeurs des attributs d&#39;objet se fait à travers des méthodes dunder. On va pouvoir modifier le comportement de ces méthodes en autorisant par exemple l&#39;accès aux attributs privés. On va ainsi garder la convention de nommage double _ pour spécifier le type privé, mais néanmoins pouvoir accéder aux données.\nclass System(object):\n\n    def __init__(self, reactions=()):\n        &quot;&quot;&quot;Initialize a new System object.&quot;&quot;&quot;\n        self.__reactions = set(reactions)\n\n    def __getattr__(self, name):\n        if name.startswith(&quot;__&quot;):\n            # get private attribute\n            return self.__dict__[&quot;&quot;.join([&quot;_&quot;,self.__class__.__name__,name])]\n        else:\n            return self.__dict__[name]\n\n    def __setattr__(self, name, value):\n        if name.startswith(&quot;__&quot;):\n            # set private attribute\n            self.__dict__[&quot;&quot;.join([&quot;_&quot;,self.__class__.__name__,name])]=value\n        else:\n            self.__dict__[name]=value\n\nImplementation avec décorateurs\nPour finir, je vous propose de voir une implémenation avec un décorateur, particularité du langage Python. Nous reviendrons dans un atelier futur sur les décorateurs, pour l&#39;instant vous pouvez simplement retenir qu&#39;un décorateur est une fonction qui va permettre d&#39;executer des pré/post traitements lorsqu&#39;il est associé à une autre fonction/méthode. Dans ce cas nous allons utiliser des décorateurs déjà fournis par le langage Python, &quot;Property&quot;, à savoir qu&#39;il est tout à fait possible de coder ses propores décorateurs. Pour plus d&#39;info un très bon blog avec de très bons liens et ressources ici\nclass System(object):\n\n    def __init__(self, reactions=()):\n        &quot;&quot;&quot;Initialize a new System object.&quot;&quot;&quot;\n        self.__reactions = set(reactions)\n\n    @property\n    def reactions(self):\n        return self.__reactions\n\n    @reactions.setter\n    def reactions(self, reactions=()):\n        self.__reactions = set(reactions)\n\nreac1 = Reaction(&quot;1&quot;)\nreac2 = Reaction(&quot;1&quot;)\nsyst = System((reac1, reac2))\nprint(syst.reactions)\nsyst.reactions = (reac1, Reaction(&quot;2&quot;))\nprint(syst.reactions)\n\nImplementation avec property()\nL&#39;implementation des décorateurs vu au dessus est inspiré de la primitive property() (property(fget=None, fset=None, fdel=None, doc=None))qui peut aussi permettre d&#39;implémenter un accès aux données:\nclass System(object):\n\n    def __init__(self, reactions=()):\n        &quot;&quot;&quot;Initialize a new System object.&quot;&quot;&quot;\n        self.__reactions = set(reactions)\n\n    def __get_reactions(self):\n        return self.__reactions\n\n    def __set_reactions(self, reactions=()):\n        self.__reactions = set(reactions)\n\n    reactions=property(__get_reactions, __set_reactions)\n\nreac1 = Reaction(&quot;1&quot;)\nreac2 = Reaction(&quot;1&quot;)\nsyst = System((reac1, reac2))\nprint(syst.reactions)\nsyst.reactions = (reac1, Reaction(&quot;2&quot;))\nprint(syst.reactions)\n\nNous avons vu ici le mécanisme de decorateur et de property pour contrôler l&#39;accès aux données. Attention, il est recommandé d&#39;éviter ce genre d&#39;implementation si il y a nécéssité d&#39;accès important et récurrent aux données. \nSi nous résumons cette partie, il faut garder à l&#39;esprit que la notion d&#39;encapsulation en python n&#39;est pas aussi restrictive que dans d&#39;autres langages comme Java par exemple. Elle est surtout utilisée pour vous aider à structurer votre code en choisissant d&#39;exposer plus ou moins certaines parties du code. L&#39;encapsulation se fait par convention de nommage et il est possible d&#39;utiliser plusieurs mécanismes pour accéder aux données ou méthodes.\nAttributs de Classe, methodes de Classe, méthodes statiques\nAttributs de Classe\nLes attributs de classe sont des attributs liés au type de la classe et non à une instance de celle-ci. Reprenons notre classe System et rajoutons un attribut de classe qui va permettre de connaitre le nombre d&#39;instance en cours de la classe. Celui se rajoute directement sous la déclaration de la classe hors de la méthode d&#39;initialisation. \nclass System(object):\n\n    nbSystems = 0\n\n    def __init__(self, reactions=()):\n        &quot;&quot;&quot;Initialize a new System object.&quot;&quot;&quot;\n        self.__reactions = set(reactions)\n        self.__class__.nbSystems += 1\n\n    def __del__(self):\n        self.__class__.nbSystems -= 1\n\n\nif __name__ == &quot;__main__&quot;:\n\n    reac1 = Reaction()\n    reac2 = Reaction()\n    syst = System((reac1, reac2))\n    print(System.nbSystems)\n    syst = System([reac1])\n    print(System.nbSystems)\n    syst2 = System([reac1])\n    print(System.nbSystems)\n    del(syst)\n    print(System.nbSystems)\n\n1\n1\n2\n1\n\nA chaque fois qu&#39;un nouvel objet est initialisé, le compteur nbSystems est incrémenté de 1. De même si un objet est supprimé, le compteur décroit de 1. \nMéthodes de Classe - Méthodes statiques\nIl est possible aussi d&#39;avoir des méthodes sur des classes qui sont utilisables s&#39;en avoir instancié un objet au préalable. Il y a les méthodes de classe, dont le rôle est en général de permettre l&#39;instanciation d&#39;objet différemment que par l&#39;instanciation normale. Ces méthodes ont simplement besoin d&#39;avoir en argument le type de la classe. Il exsite aussi les méthodes statiques, qui elles n&#39;ont aucun pré-requis et peuvent être directement appelées depuis le type de la classe. Elles sont souvent utilisées pour faire des classes dites utilitaires.\nModifions notre classe System en créant une méthode de classe qui va nous permettre de générer un nouveau System en réunissant une liste de System passée en arguments. Simultanément, nous allons implémenter une méthode statique qui va nous permettre d&#39;avoir la somme des réactions présents dans une liste de System.  \nclass System(object):\n\n    nbSystems = 0\n\n    def __init__(self, reactions=()):\n        &quot;&quot;&quot;Initialize a new System object.&quot;&quot;&quot;\n        self.__reactions = set(reactions)\n        self.__class__.nbSystems += 1\n\n    def __del__(self):\n        self.__class__.nbSystems -= 1\n\n    @property\n    def reactions(self):\n        return self.__reactions\n\n    @reactions.setter\n    def reactions(self, reactions=()):\n        self.__reactions = set(reactions)\n\n    @classmethod\n    def merge_systems(cls,systems=[]):\n\n        lreactions = []\n        for sys in systems:\n            lreactions.extend(sys.reactions)\n\n        return cls(set(lreactions))\n\n    @staticmethod\n    def count_reactions(systems=[]):\n\n        return sum([len(syst.reactions) for syst in systems])\n\nif __name__ == &quot;__main__&quot;:\n\n   syst = System((&quot;reac1&quot;, &quot;reac2&quot;))\n   print(System.nbSystems)\n   print(syst.reactions)\n   syst2 = System((&quot;reac1&quot;, &quot;reac3&quot;))\n   print(System.nbSystems)\n   print(syst2.reactions)\n   syst3 = System.merge_systems([syst,syst2])\n   print(System.nbSystems)\n   print(syst3.reactions)\n   print(System.count_reactions([syst,syst2,syst3]))\n\n\n1\nset([&#39;reac1&#39;, &#39;reac2&#39;])\n2\nset([&#39;reac1&#39;, &#39;reac3&#39;])\n3\nset([&#39;reac1&#39;, &#39;reac2&#39;, &#39;reac3&#39;])\n7\n\nPour info, il est possible de ne pas utiliser de decorator pour spécifier le type classmethod ou staticmethod en utilisant des primitives:\n    def merge_systems(cls,systems=[]):\n\n        lreactions = []\n        for sys in systems:\n            lreactions.extend(sys.reactions)\n\n        return cls(set(lreactions))\n    merge_systems = classmethod(merge_systems)\n\n    def count_reactions(systems=[]):\n\n        return sum([len(syst.reactions) for syst in systems])\n    count_reactions = staticmethod(count_reactions)\n\n\nHéritage, Polymorphisme, Surchage d&#39;opérateurs\nL&#39;héritage consiste à dériver des classes en sous-classes. Une sous-classe (classe fille) hérite alors de toutes les caractéristiques (attributs, méthodes) de la classe (classe mère). La classe fille peut en plus ajouter ses propres méthodes/attributs, ou même modifier des méthodes existantes, dans ce cas on parle de surcharge d&#39;opérateurs. La classe fille est une spécilisation de la classe mère.\nPour exemple, prenons une partie du code de l&#39;outil web Galaxy et plus précisement l&#39;implémentation des types d&#39;exceptions:\nclass MessageException(Exception):\n    &quot;&quot;&quot;Most generic Galaxy exception - indicates merely that some exceptional condition happened.&quot;&quot;&quot;\n    # status code to be set when used with API.\n    status_code = 400\n    # Error code information embedded into API json responses.\n    err_code = &quot;UNKNOWN&quot;\n\n    def __init__(self, err_msg=None, type=&quot;info&quot;, **extra_error_info):\n        self.err_msg = err_msg or self.err_code\n        self.type = type\n        self.extra_error_info = extra_error_info\n\n    def __str__(self):\n        return self.err_msg\n\nclass DuplicatedSlugException(MessageException):\n    status_code = 400\n    err_code = &quot;USER_SLUG_DUPLICATE&quot;\n\nclass DuplicatedIdentifierException(MessageException):\n    status_code = 400\n    err_code = &quot;USER_IDENTIFIER_DUPLICATE&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n\n    print(MessageException())\n    print(MessageException(&quot;unknown&quot;))\n    print(DuplicatedSlugException())\n    print(DuplicatedSlugException(&quot;duplicate&quot;))\n\nrésultats:\nUNKNOWN\nunknown\nUSER_SLUG_DUPLICATE\nduplicate\nDans le cas où un message est passé à l&#39;exception demandée, c&#39;est le message en argument qui est affiché. Sans message explicite, c&#39;est l&#39;err_code qui est retourné selon la classe. L&#39;affichage est réalisé grâce à l&#39;implémentation de la méthode __str__ dans la classe mère MessageException.\nNous allons maintenant réaliser une surcharge de la méthode __str__ dans la classe DuplicatedIdentifierException afin de spécialiser son affichage.\nclass MessageException(Exception):\n    &quot;&quot;&quot;Most generic Galaxy exception - indicates merely that some exceptional condition happened.&quot;&quot;&quot;\n    # status code to be set when used with API.\n    status_code = 400\n    # Error code information embedded into API json responses.\n    err_code = &quot;UNKNOWN&quot;\n\n    def __init__(self, err_msg=None, type=&quot;info&quot;, **extra_error_info):\n        self.err_msg = err_msg or self.err_code\n        self.type = type\n        self.extra_error_info = extra_error_info\n\n    def __str__(self):\n        return self.err_msg\n\nclass DuplicatedSlugException(MessageException):\n    status_code = 400\n    err_code = &quot;USER_SLUG_DUPLICATE&quot;\n\nclass DuplicatedIdentifierException(MessageException):\n    status_code = 400\n    err_code = &quot;USER_IDENTIFIER_DUPLICATE&quot;\n\n    def __str__(self):\n        return f&quot;my specialized method:{self.err_msg}&quot;\n\n\nif __name__ == &quot;__main__&quot;:\n\n    print(MessageException())\n    print(MessageException(&quot;unknown&quot;))\n    print(DuplicatedSlugException())\n    print(DuplicatedSlugException(&quot;duplicate&quot;))\n    print(DuplicatedIdentifierException(&quot;&quot;))\n    print(DuplicatedIdentifierException(&quot;duplicate&quot;))\n\nrésulats:\nUNKNOWN\nunknown\nUSER_SLUG_DUPLICATE\nduplicate\nmy specialized method:USER_IDENTIFIER_DUPLICATE\nmy specialized method:duplicate\n\nEn surchargeant notre methode, nous avons introduit un polymorphisme d&#39;héritage. La méthode __str__ est devenue polymorphique, car elle propose une implémentation différente selon la classe de l&#39;objet.\nAbstraction, Interfaces\nNous allons maintenant nous intéresser très brièvement au concept de classe abstraite et d&#39;interface. Pour cet atelier, ce paragraphe sera relativement court pour ne pas tout de suite introduire trop d&#39;élèment complexe du langage Python. En effet cette partie sera grandement plus couverte dans un prochain atelier avec des approches plus &quot;pythonesques&quot; via le module abc, les Abstract Base Class du module collections et les metaclass. Pour l&#39;instant concentrons nous sur une approche généraliste.\nDe façon simple, une classe abstraite est une classe qui ne peut pas être instanciée, mais dont il faut absolument hériter pour en utiliser les méthodes. Par ailleurs, ses méthodes peuvent être implémentées ou non. Dans ce dernier cas, il est alors nécessaire de les surcharger dans les classes filles.\nAfin d&#39;illustrer ce concept, nous allons nous intéresser à la classe abstraite AbstractCommandline de la Biopython. Cette classe sert de base pour appeler un programme et l&#39;executer. Elle contient tout un ensemble de méthodes pour construire la ligne de commande à lancer, ainsi que lancer le programme demandé. Grâce à ce mécanisme, la création d&#39;un nouveau &quot;wrapper&quot; d&#39;outil est très simplifié. Dans ce cas précis, la seule contrainte demandé au classe filles est de définir la liste des paramètres nécéssaires à la construction de la ligne de commande. Voyons ça en détails:\nclass AbstractCommandline(object):\n    r&quot;&quot;&quot;Generic interface for constructing command line strings.\n\n    This class shouldn&#39;t be called directly; it should be subclassed to\n    provide an implementation for a specific application.\n...\n    &quot;&quot;&quot;\n    parameters = None  # will be a list defined in subclasses\n\n    def __init__(self, cmd, **kwargs):\n        &quot;&quot;&quot;Create a new instance of a command line wrapper object.&quot;&quot;&quot;\n        # Init method - should be subclassed!\n        #\n        # The subclass methods should look like this:\n        #\n        # def __init__(self, cmd=&quot;muscle&quot;, **kwargs):\n        #     self.parameters = [...]\n        #     AbstractCommandline.__init__(self, cmd, **kwargs)\n        #\n\n        self.program_name = cmd\n        try:\n            parameters = self.parameters\n        except AttributeError:\n            raise AttributeError(&quot;Subclass should have defined self.parameters&quot;)\n        # Create properties for each parameter at run time\n        aliases = set()\n...\n\nUtilisation de la classe abstraite pour générer une commande samtools view:\nclass SamtoolsViewCommandline(AbstractCommandline):\n    &quot;&quot;&quot;Command line wrapper for samtools view.\n\n...\n    def __init__(self, cmd=&quot;samtools&quot;, **kwargs):\n        &quot;&quot;&quot;Initialize the class.&quot;&quot;&quot;\n        self.program_name = cmd\n        self.parameters = [\n            _StaticArgument(&quot;view&quot;),\n            _Switch([&quot;-b&quot;, &quot;b&quot;], &quot;Output in the BAM format&quot;),\n...\n            _Argument([&quot;region&quot;], &quot;Region&quot;, is_required=False),\n        ]\n        AbstractCommandline.__init__(self, cmd, **kwargs)\n\nModifions la classe abstraite de façon à ce qu&#39;elle impose aux classes filles l&#39;implementation d&#39;une méthode dry_run:\nclass AbstractCommandline(object):\n    ...\n\n        def dry_run(self):\n            raise NotImplementedError(&#39;need to be implemented&#39;)\n\nAinsi, dans le cas où une classe fille souhaiterait appeler la méthode dry_run, si cette dernière n&#39;implemente pas sa propre méthode, une exception sera levée. \nImplémentation\nL&#39;exercice consiste à se placer dans la situation de lecture d&#39;un fichier d&#39;annotation sur lequel on souhaite faire quelques statistiques basiques. Pour cela nous allons implémenter une classe Abstraite AbstractFeature qui servira de base à la création de 2 classes filles Gene et Transcript. Ces 2 sous-classes ont aussi une relation de composition, puisqu&#39;un gène peut avoir 1 ou plusieurs transcripts. En \nparallèle, nous allons implémenter une classe &quot;utilitaire&quot; Stats, qui nous permettra de réaliser des statistiques simples sur nos Features. Pour vous aider voici la modélisation de UML de l&#39;implémentation attendue:\n\nImplementez les 4 classes dans le même fichier et rajoutez le code suivant, à la suite des 4 classes.\nif __name__ == &quot;__main__&quot;:\n\n    gene1 = Gene(&quot;chr1&quot;, 1000, 2000, &quot;gene1&quot;)\n    mRNA1 = Transcript(&quot;chr1&quot;, 1000, 2000, &quot;mRNA1&quot;, &quot;gene1&quot;)\n    gene2 = Gene(&quot;chr1&quot;, 10000, 12000, &quot;gene2&quot;)\n    mRNA2 = Transcript(&quot;chr1&quot;, 10000, 12000, &quot;mRNA2&quot;, &quot;gene2&quot;)\n    mRNA3 = Transcript(&quot;chr1&quot;, 10000, 11400, &quot;mRNA3&quot;, &quot;gene2&quot;)\n\n    print(gene1+gene2)\n    print(sum((gene1,gene2)))\n    print(f&quot;Gene mean length: {Stats.mean([gene1,gene2])}&quot;)\n    print(f&quot;Transcript mean length: {Stats.mean([mRNA1,mRNA2,mRNA3])}&quot;)\n\nExecutez le script, voici le résultat que vous devez obtenir:\n3002\n3002\nGene mean length: 1501.0\nTranscript mean length: 1467.6666666666667\nLa solution est ici\nRetour sur l&#39;atelier\nNous avons rajouter de nouveaux éléments dans l&#39;utilisation de la POO en Python. \nPour rappel, Python est un langage assez permissif et ne propose pas de typage fort. L&#39;implementation de certains concepts objets peut se faire à l&#39;encontre de la philosophie du langage, mais peut néanmoins être intéressant pour structurer son code et son programme. Dans un futur atelier nous aborderons des concepts très &quot;pythonesques&quot; que sont le duck-typing, les metaclasse et le module ABC.\nRéférences\nQuelques liens intéressants qui ont servi à faire cet atelier:\n\nencapsulation\nproperties-decorateurs\ndecorateurs\ndecorateurs\ndecorateurs\n\n", "tags": "", "url": "category/python/python-s2.html"},
		{"title": "Python, tester son code", "text": "Python tester son code pour le rendre plus fiable\nIntroduction\nAfin de rendre son code plus robuste et plus fiable, il est impératif de mettre en place un ensemble de tests permettant de valider le fonctionnement du code. Les tests sont les garants du résultat. Par ailleurs, pour qu&#39;un code soit facilement testable, il faut qu&#39;il soit modulable et atomique. Un code sera d&#39;autant plus facilement testable que l&#39;on pourra isoler de petites parties et controller spécifiquement l&#39;execution. Il y a énormément de choses à dire autour des tests de code. Cet atelier permet d&#39;aborder les bases et de pouvoir mettre en place un jeu de tests autour d&#39;un module. Pour aller plus loin, vous pouvez vous intéresser au TDD (Test Driven Development), dont la mentalité est le test avant tout. \nLes tests, qu&#39;est ce que c&#39;est ?\nPour appréhender ce qu&#39;est un test, le plus simple est d&#39;aller faire un peu de revue de code sur notre package bioinfo préféré: la biopython. Si vous récupérez le code de la biopython ou que vous naviguez sur sa documentation ici, vous remarquerez qu&#39;il y a un dossier Tests. Ce dossier contient l&#39;ensemble des tests immplémentés pour les modules de la Biopython. Comme nous le verrons plus loin en plus d&#39;aider au développement ils pourront être joués lors de l&#39;installation du package. Les tests ont donc un intérêt lors du développement mais aussi pendant le déploiement du code.\nRegardons de plus près le fichier de test: test_File.py\nfrom __future__ import print_function\n\nimport os.path\nimport shutil\nimport sys\nimport tempfile\nimport unittest\n\nfrom Bio import bgzf\nfrom Bio import File\nfrom Bio._py3k import StringIO\n\ndata = &quot;&quot;&quot;This\nis\na multi-line\nfile&quot;&quot;&quot;\n\n...\n\n\nclass RandomAccess(unittest.TestCase):\n\n    def test_plain(self):\n        with File._open_for_random_access(&quot;Quality/example.fastq&quot;) as handle:\n            self.assertTrue(&quot;r&quot; in handle.mode)\n            self.assertTrue(&quot;b&quot; in handle.mode)\n\n    def test_bgzf(self):\n        with File._open_for_random_access(&quot;Quality/example.fastq.bgz&quot;) as handle:\n            self.assertIsInstance(handle, bgzf.BgzfReader)\n\n    def test_gzip(self):\n        self.assertRaises(ValueError,\n                          File._open_for_random_access,\n                          &quot;Quality/example.fastq.gz&quot;)\n\nLe fichier de tests comporte plusieurs classes qui héritent toute de unittest.TestCase, classe TestCase du module de test unittest. Chaque classe implémente plusieurs méthodes commençant par test, qui correspond plus ou moins à un test. Néanmoins chaque test peut comporter plusieurs valeurs testées. En héritant de TestCase, les classes créées vont bénéficier d&#39;un grand ensemble de méthodes de test. Par exemple, la première méthode test_plain() va éssayer 2 assertions. Quand j&#39;ouvre le fichier fastq (de test) &quot;Quality/example.fastq&quot; via la méthode _open_for_random_access(), est ce que le fichier est en mode &#39;r&#39; et &#39;b&#39; ?\nRegardons maintenant la classe de test suivante. \nclass AsHandleTestCase(unittest.TestCase):\n\n    def setUp(self):\n        # Create a directory to work in\n        self.temp_dir = tempfile.mkdtemp(prefix=&#39;biopython-test&#39;)\n\n    def tearDown(self):\n        shutil.rmtree(self.temp_dir)\n\n    def _path(self, *args):\n        return os.path.join(self.temp_dir, *args)\n\n    def test_handle(self):\n        &quot;Test as_handle with a file-like object argument&quot;\n        p = self._path(&#39;test_file.fasta&#39;)\n        with open(p, &#39;wb&#39;) as fp:\n            with File.as_handle(fp) as handle:\n                self.assertEqual(fp, handle, &quot;as_handle should &quot;\n                                 &quot;return argument when given a &quot;\n                                 &quot;file-like object&quot;)\n                self.assertFalse(handle.closed)\n\n            self.assertFalse(handle.closed,\n                             &quot;Exiting as_handle given a file-like object &quot;\n                             &quot;should not close the file&quot;)\n\n    def test_string_path(self):\n        &quot;Test as_handle with a string path argument&quot;\n        p = self._path(&#39;test_file.fasta&#39;)\n        mode = &#39;wb&#39;\n        with File.as_handle(p, mode=mode) as handle:\n            self.assertEqual(p, handle.name)\n            self.assertEqual(mode, handle.mode)\n            self.assertFalse(handle.closed)\n        self.assertTrue(handle.closed)\n\n    @unittest.skipIf(\n        sys.version_info &lt; (3, 6),\n        &#39;Passing Path objects to File.as_handle requires Python &gt;= 3.6&#39;,\n    )\n    def test_path_object(self):\n        &quot;Test as_handle with a pathlib.Path object&quot;\n        from pathlib import Path\n        p = Path(self._path(&#39;test_file.fasta&#39;))\n        mode = &#39;wb&#39;\n        with File.as_handle(p, mode=mode) as handle:\n            self.assertEqual(str(p.absolute()), handle.name)\n            self.assertEqual(mode, handle.mode)\n            self.assertFalse(handle.closed)\n        self.assertTrue(handle.closed)\n\n    @unittest.skipIf(\n        sys.version_info &lt; (3, 6),\n        &#39;Passing path-like objects to File.as_handle requires Python &gt;= 3.6&#39;,\n    )\n    def test_custom_path_like_object(self):\n        &quot;Test as_handle with a custom path-like object&quot;\n        class CustomPathLike:\n            def __init__(self, path):\n                self.path = path\n\n            def __fspath__(self):\n                return self.path\n\n        p = CustomPathLike(self._path(&#39;test_file.fasta&#39;))\n        mode = &#39;wb&#39;\n        with File.as_handle(p, mode=mode) as handle:\n            self.assertEqual(p.path, handle.name)\n            self.assertEqual(mode, handle.mode)\n            self.assertFalse(handle.closed)\n        self.assertTrue(handle.closed)\n\n    def test_stringio(self):\n        s = StringIO()\n        with File.as_handle(s) as handle:\n            self.assertIs(s, handle)\n\n\nif __name__ == &quot;__main__&quot;:\n    runner = unittest.TextTestRunner(verbosity=2)\n    unittest.main(testRunner=runner)\n\nPlusieurs choses intéressantes sont à noter. L&#39;héritage de TestCase vous donne la possibilité de surcharger les méthodes setUp() et tearDown() qui seront utilisées respectivement avant les tests et après les tests. Vous pouvez donc via ces méthodes, configurer plus facilement votre environnement de test en spécifiant des attributs partagés. \nNous pouvons voir aussi que certaines méthodes comportent des décorateurs (`@unittest.skipIf`). Plusieurs décorateurs existent permettant par exemple de ne pas executer le test, ce qui est utile en phase de développement ou de résolution de bugs, ou encore de spéficier des contraintes pour son execution (module necessaire, version de Python, ...).\nIl existe donc un grand nombre de méthodes d&#39;assertion ou de control d&#39;execution des tests. Afin de ne pas reprendre l&#39;ensemble des possibilités ici, le plus simple est d&#39;explorer la documentation de unittest. \nExécutons maintenant les tests. Grâce au __main__ implémenté dans le fichier nous pouvons lancer la suite de tests:\npython test_File.py\ntest_custom_path_like_object (__main__.AsHandleTestCase)\nTest as_handle with a custom path-like object ... skipped &#39;Passing path-like objects to File.as_handle requires Python &gt;= 3.6&#39;\ntest_handle (__main__.AsHandleTestCase)\nTest as_handle with a file-like object argument ... ok\ntest_path_object (__main__.AsHandleTestCase)\nTest as_handle with a pathlib.Path object ... skipped &#39;Passing Path objects to File.as_handle requires Python &gt;= 3.6&#39;\ntest_string_path (__main__.AsHandleTestCase)\nTest as_handle with a string path argument ... ok\ntest_stringio (__main__.AsHandleTestCase) ... ok\ntest_bgzf (__main__.RandomAccess) ... ok\ntest_gzip (__main__.RandomAccess) ... FAIL\ntest_plain (__main__.RandomAccess) ... ok\ntest_one (__main__.UndoHandleTests) ... ok\ntest_read (__main__.UndoHandleTests)\nTest read method ... ok\ntest_undohandle_read_block (__main__.UndoHandleTests) ... ok\n\n======================================================================\nFAIL: test_gzip (__main__.RandomAccess)\n----------------------------------------------------------------------\nTraceback (most recent call last):\n  File &quot;test_File.py&quot;, line 85, in test_gzip\n    &quot;Quality/example.fastq.gz&quot;)\nAssertionError: ValueError not raised\n\n----------------------------------------------------------------------\nRan 11 tests in 0.002s\n\nFAILED (failures=1, skipped=2)\nNous pouvons voir que les tests se sont executés les uns après les autres dans l&#39;orde alphabétique. Un test a échoué, le détail apparaît alors en fin de la suite de test. \nDoctest: le mélange de la documentation et du test\nUne autre façon de faire des tests est l&#39;utilisation du module doctest de python. Le but principal de doctest est de pouvoir très facilement intégrer des cas de tests du code au plus près de l&#39;implémentation. Cela limite le nombre de fichier crée en revanche cela peut aussi alourdir le code et rendre moins lisible la partie &#39;vrai code&#39; de votre fichier. L&#39;utilisation de doctest n&#39;est pas incompatible avec d&#39;autre type de module, c&#39;est simplement une philosphie différente. \nLe fonctionnement de cas de tests imbriqués au milieu du code, se fait par la recherche de &gt;&gt;&gt; au milieu de commentaires. Les tests peuvent ensuite être joués de différentes manières. Pour bien comprendre le lancement des tests via doctest, il faut s&#39;imaginer l&#39;ouverture d&#39;un shell Python dans lequel vous lancez des commandes. Chaque retour de vos commandes peut être ensuite testé.\nComme toujours, une revue de code est bien plus efficace que de longues explications. Intéressons nous donc au module Bio.Seq de la biopython. Voici un extrait de sa méthode __init()__:\ndef __init__(self, data, alphabet=Alphabet.generic_alphabet):\n    &quot;&quot;&quot;Create a Seq object.\n    Arguments:\n    - seq - Sequence, required (string)\n    - alphabet - Optional argument, an Alphabet object from\n    Bio.Alphabet\n    You will typically use Bio.SeqIO to read in sequences from files as\n    SeqRecord objects, whose sequence will be exposed as a Seq object via\n    the seq property.\n    However, will often want to create your own Seq objects directly:\n    &gt;&gt;&gt; from Bio.Seq import Seq\n    &gt;&gt;&gt; from Bio.Alphabet import IUPAC\n    &gt;&gt;&gt; my_seq = Seq(&quot;MKQHKAMIVALIVICITAVVAALVTRKDLCEVHIRTGQTEVAVF&quot;,\n    ...              IUPAC.protein)\n    &gt;&gt;&gt; my_seq\n    Seq(&#39;MKQHKAMIVALIVICITAVVAALVTRKDLCEVHIRTGQTEVAVF&#39;, IUPACProtein())\n    &gt;&gt;&gt; print(my_seq)\n    MKQHKAMIVALIVICITAVVAALVTRKDLCEVHIRTGQTEVAVF\n    &gt;&gt;&gt; my_seq.alphabet\n    IUPACProtein()\n    &quot;&quot;&quot;\n    # Enforce string storage\n    if not isinstance(data, basestring):\n        raise TypeError(&quot;The sequence data given to a Seq object should &quot;\n                        &quot;be a string (not another Seq object etc)&quot;)\n    self._data = data\n    self.alphabet = alphabet # Seq API requirement\n\nOn peut voir que 3 tests ont été implémentés. Le premier qui test le retour de my_seq, le second de print(my_seq) et enfin my_seq.alphabet. Maintenant, si nous regardons la fin du fichier, le __main__ de l&#39;objet a été implémenté avec:\ndef _test():\n    &quot;&quot;&quot;Run the Bio.Seq module&#39;s doctests (PRIVATE).&quot;&quot;&quot;\n    print(&quot;Running doctests...&quot;)\n    import doctest\n    doctest.testmod(optionflags=doctest.IGNORE_EXCEPTION_DETAIL)\n    print(&quot;Done&quot;)\n\nif __name__ == &quot;__main__&quot;:\n_test()\n\n\nAinsi, l&#39;objet (module) peut-être directement utilisé comme un script si il est appelé directement (via __main__). Dans ce cas, il y aura execution des tests doctest via la méthode doctest.testmod(). C&#39;est ce que nous faisons si dessous:\npython3.7 -m Bio.Seq\n\nRunning doctests...\n/home/nlapalu/Workspace/Github/biopython/Bio/Seq.py:441: BiopythonDeprecationWarning: This method is obsolete; please use str(my_seq) instead of my_seq.tostring().\n  BiopythonDeprecationWarning)\n/home/nlapalu/Workspace/Github/biopython/Bio/Seq.py:2626: BiopythonWarning: This table contains 2 codon(s) which code(s) for both STOP and an amino acid (e.g. &#39;TGA&#39; -&gt; &#39;W&#39; or STOP). Such codons will be translated as amino acid.\n  BiopythonWarning)\nDone\nPour avoir plus d&#39;info, il faut demander le mode verbose\npython3.7 -m Bio.Seq -v \n\n/home/nlapalu/Workspace/Github/biopython/Bio/Seq.py:441: BiopythonDeprecationWarning: This method is obsolete; please use str(my_seq) instead of my_seq.tostring().\n  BiopythonDeprecationWarning)\nRunning doctests...\nTrying:\n    from Bio.Seq import MutableSeq\nExpecting nothing\nok\nTrying:\n    from Bio.Alphabet import generic_dna\nExpecting nothing\nok\nTrying:\n    my_seq = MutableSeq(&quot;ACTCGTCGTCG&quot;, generic_dna)\nExpecting nothing\nok\nTrying:\n    my_seq\nExpecting:\n    MutableSeq(&#39;ACTCGTCGTCG&#39;, DNAAlphabet())\nok\n\n...\n\n   6 tests in __main__.UnknownSeq.transcribe\n  10 tests in __main__.UnknownSeq.translate\n  10 tests in __main__.UnknownSeq.ungap\n   7 tests in __main__.UnknownSeq.upper\n  10 tests in __main__._translate_str\n   1 tests in __main__.back_transcribe\n   1 tests in __main__.complement\n   1 tests in __main__.reverse_complement\n   1 tests in __main__.transcribe\n  15 tests in __main__.translate\n449 tests in 103 items.\n449 passed and 0 failed.\nTest passed.\nDone\nUn des problème de doctest est sa sensibilité au retour du test. En effet, ce qui est vraiment testé est une chaine de caractères qui correspond à l&#39;affichage interactif de votre commande. Il suffit donc d&#39;un léger écart dans la chaîne de retour pour que le test soit faux (exemple un espace vide à la fin de votre test). Si vous souhiatez donc utiliser doctest il faut essayer de faire des tests qui limiteront ces possibles problèmes. De même si vous souhaitez connaître toutes les subtilités du module, la documentation officielle est ici: doctest\nCohabitation unittest et doctest\nNous venons de voir 2 façons de faire des tests via unittest ou doctest. Les 2 ont des pours et des contres. On veut vouloir par exemple plutôt faire du doctest sur des objets de type entité et plutôt de l&#39;unittest sur du traitement. Bref, le mélange des 2 apparaît une bonne solution. Il est tout à fait possible de pouvoir appeler par exemple les tests générés via doctest dans une classe TestCase cela grâce à une méthode spéciale  load_tests(). Nous ne détaillerons pas plus ici cette possibilité, mais nous essayerons de nous en servir dans l&#39;implémentation à réaliser. \nLes différents modules de tests\nClairement il y a de gandes chances qu&#39;il ne vous soit pas nécessaire d&#39;utiliser d&#39;autres modules de tests que unittest et doctest. Neanmoins sachez qu&#39;il existe d&#39;autres modules:\n\npy.test\nNose\ntox\nunittest2\n\nPlus d&#39;info ici\nIntégration dans le packaging de module\nLe dernier point que nous aborderons est lié au packaging de vos modules. Nous ferons un atelier spécifique sur cet aspect, mais sachez que tous les tests que vous avez implémentés peuvent vous servir de pré-requis à l&#39;installation de votre package. En effet, il est tres courant d&#39;avoir une tache (commande) test lors de l&#39;installation de votre package. Elle est la plupart du temps accessoire et il faut la forcer en faisant: python setup.py test. Si nous regardons le fichier de packaging setup.py de la biopython, cette tache est bien présente:\nsetup(name=&#39;biopython&#39;,\n      version=__version__,\n      author=&#39;The Biopython Contributors&#39;,\n      author_email=&#39;biopython@biopython.org&#39;,\n      url=&#39;https://biopython.org/&#39;,\n      description=&#39;Freely available tools for computational molecular biology.&#39;,\n      long_description=readme_rst,\n      classifiers=[\n          &#39;Development Status :: 5 - Production/Stable&#39;,\n          &#39;Intended Audience :: Developers&#39;,\n          &#39;Intended Audience :: Science/Research&#39;,\n          &#39;License :: Freely Distributable&#39;,\n          # Technically the &quot;Biopython License Agreement&quot; is not OSI approved,\n          # but is almost https://opensource.org/licenses/HPND so might put:\n          # &#39;License :: OSI Approved&#39;,\n          # To resolve this we are moving to dual-licensing with 3-clause BSD:\n          # &#39;License :: OSI Approved :: BSD License&#39;,\n          &#39;Operating System :: OS Independent&#39;,\n          &#39;Programming Language :: Python&#39;,\n          &#39;Programming Language :: Python :: 2&#39;,\n          &#39;Programming Language :: Python :: 2.7&#39;,\n          &#39;Programming Language :: Python :: 3&#39;,\n          &#39;Programming Language :: Python :: 3.4&#39;,\n          &#39;Programming Language :: Python :: 3.5&#39;,\n          &#39;Programming Language :: Python :: 3.6&#39;,\n          &#39;Topic :: Scientific/Engineering&#39;,\n          &#39;Topic :: Scientific/Engineering :: Bio-Informatics&#39;,\n          &#39;Topic :: Software Development :: Libraries :: Python Modules&#39;,\n      ],\n      cmdclass={\n          &quot;install&quot;: install_biopython,\n          &quot;build_py&quot;: build_py_biopython,\n          &quot;build_ext&quot;: build_ext_biopython,\n          &quot;test&quot;: test_biopython,\n      },\n      packages=PACKAGES,\n      ext_modules=EXTENSIONS,\n      package_data={\n          &#39;Bio.Entrez&#39;: [&#39;DTDs/*.dtd&#39;,\n                         &#39;DTDs/*.ent&#39;,\n                         &#39;DTDs/*.mod&#39;,\n                         &#39;XSDs/*.xsd&#39;],\n      },\n      install_requires=REQUIRES,\n      ) \n\nLa tache appelle la classe test_biopython qui hérite de Command, dont la méthode run() permettra l&#39;execution de l&#39;ensemble des fichiers de tests:\nclass test_biopython(Command):\n    &quot;&quot;&quot;Run all of the tests for the package.\n\n    This is a automatic test run class to make distutils kind of act like\n    perl. With this you can do:\n\n    python setup.py build\n    python setup.py install\n    python setup.py test\n\n    &quot;&quot;&quot;\n\n    description = &quot;Automatically run the test suite for Biopython.&quot;\n    user_options = []\n\n    def initialize_options(self):\n        &quot;&quot;&quot;No-op, initialise options.&quot;&quot;&quot;\n        pass\n\n    def finalize_options(self):\n        &quot;&quot;&quot;No-op, finalise options.&quot;&quot;&quot;\n        pass\n\n    def run(self):\n        &quot;&quot;&quot;Run the tests.&quot;&quot;&quot;\n        this_dir = os.getcwd()\n\n        # change to the test dir and run the tests\n        os.chdir(&quot;Tests&quot;)\n        sys.path.insert(0, &#39;&#39;)\n        import run_tests\n        run_tests.main([])\n\n        # change back to the current directory\n        os.chdir(this_dir)\n\nImplémentation\nNous allons utiliser l&#39;implémentation de la class System réalisée dans l&#39;atelier POO Python suite pour mettre en place une série de tests. Afin de couvrir les notions vues dans l&#39;atelier, nous allons à la fois implémenter des tests unitaires avec unittest et doctest. Pour rappel, voici l&#39;implémentation de la class System: \nclass System(object):\n\n    nbSystems = 0\n\n    def __init__(self, reactions=()):\n        &quot;&quot;&quot;Initialize a new System object.&quot;&quot;&quot;\n        self.__reactions = set(reactions)\n        self.__class__.nbSystems += 1\n\n    def __del__(self):\n        self.__class__.nbSystems -= 1\n\n    @property\n    def reactions(self):\n        return self.__reactions\n\n    @reactions.setter\n    def reactions(self, reactions=()):\n        self.__reactions = set(reactions)\n\n    @classmethod\n    def merge_systems(cls,systems=[]):\n\n        lreactions = []\n        for sys in systems:\n            lreactions.extend(sys.reactions)\n\n        return cls(set(lreactions))\n\n    @staticmethod\n    def count_reactions(systems=[]):\n\n        return sum([len(syst.reactions) for syst in systems])\n\nif __name__ == &quot;__main__&quot;:\n\n   syst = System((&quot;reac1&quot;, &quot;reac2&quot;))\n   print(System.nbSystems)\n   print(syst.reactions)\n   syst2 = System((&quot;reac1&quot;, &quot;reac3&quot;))\n   print(System.nbSystems)\n   print(syst2.reactions)\n   syst3 = System.merge_systems([syst,syst2])\n   print(System.nbSystems)\n   print(syst3.reactions)\n   print(System.count_reactions([syst,syst2,syst3]))\n\n\n1\nset([&#39;reac1&#39;, &#39;reac2&#39;])\n2\nset([&#39;reac1&#39;, &#39;reac3&#39;])\n3\nset([&#39;reac1&#39;, &#39;reac2&#39;, &#39;reac3&#39;])\n7\n\nTout d&#39;abord, vous allez implementer une classe de test TestSystem qui héritera de unittest.TestCase. Cette classe implémentera 2 méthodes qui vous permettront de tester merge_systems() et count_reactions() de la classe System. Point important, il vous sera nécessaire de modifier l&#39;implémentation de la classe System pour pouvoir tester l&#39;égalité de 2 instances de System. Pour cela souvenez vous (atelier 1: POO) des méthodes dunder qui permettent de comparer des objets et des instances d&#39;objets. \nPar la suite, vous éliminez le code situé dans le __main__ de System pour le placer sous forme de doctest dans l&#39;__init__ de System.\nNous verrons ensuite ensemble comment appeler les doctest depuis votre fichier de tests, grâce à la méthode load_tests().\nLa solution est ici\nRetour sur l&#39;atelier\nVous êtes maintenant capable d&#39;implémenter des tests sur votre code. Retenez bien que l&#39;intérêt des tests est multiple:\n\ncontrôle des bugs et de la régression du code\nmaintenabilité du code\naide au développement\nfacilite l&#39;intégration dans des environnements divers\n\nIl faut néanmoins faire attention à ne pas sur-tester votre code. Maintenir et écrire des tests à un coût, il faut que cela soit justifié.\nPour compléter cet atelier sur les tests, nous aurions pu aussi aborder la notion de couverture de code. Cette métrique suplémentaire permet de vérifier que l&#39;ensemble du code écrit est utilisé dans au moins un cas et que chacun de ces cas est vérifé par un ou des tests (à voir pour un prochain atelier).\nRéférences\n\ndoc officielle - doctest\ndoc officielle - unittest\ntest-unitaires\ntest tous les aspects\ntest\n\n", "tags": "", "url": "category/python/python-s3.html"},
		{"title": "Python scientifique - session 1", "text": "Python scientifique ...\nIntroduction\nblbla plusieurs session 1 \nTester le temps d&#39;execution du code:\nTester l&#39;empreinte mémoire du code:\n", "tags": "", "url": "category/python/python-s4.html"},
		{"title": "Accueil", "text": "Welcome!\n", "tags": "", "url": "index.html"}
	]
}
