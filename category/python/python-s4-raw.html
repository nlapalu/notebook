<pre>

# Python scientifique ... 

## Introduction

blbla plusieurs session 1 

## Execution du code temps/mémoire

### Calculer le temps d'éxecution

Si vous êtes sous linux et que vous souhaitez simplement tester le temps d'execution d'un script, le plus simple est d'utiliser la commande system `time`.

_time.py:_
```python
#!/usr/bin/env python3

import time
time.sleep(5)
```
execution:
```sh
time ./time.py

real    0m5.050s
user    0m0.036s
sys     0m0.008s
```

Pour un affichage plus complet:
```sh
/usr/bin/time -v ./time.py
```

Si vous souhaitez mesurer le temps d'execution de seulement une partie de votre code, il existe plusieurs modules qui vous permettront de faire cela. Néanmoins, ils ne vous permettront pas tous de pouvoir controler finement le vrai temps d'execution.

module time: _time.py_
```python
#!/usr/bin/env python3

import time
# timing with system date
start = time.time()
print(start)
time.sleep(5)
print("{} sec".format(time.time()-start))
# timing with counter
start = time.perf_counter()
time.sleep(5)
print(start)
print("{} sec".format(time.perf_counter()-start))
# timing with execution time without sleep time
start = time.process_time()
print(start)
time.sleep(5)
print("{} sec".format(time.process_time()-start))
```
execution:
```
./time.py

1590570012.7908258  # temps depuis epoch, dependant system
5.005113124847412 sec
3783981.080605406 # counter
5.005108261015266 sec
0.038772806 # somme du temps system et cpu depuis du process en cours, sans le temps d'inactivité 
4.544399999999865e-05 sec
```

Pour info, `perf_counter()` et `process_time()` existent en version nanoseconds pour les executions rapides `perf_counter_ns()` et `process_time_ns()` 


Le module timeit a été pensé pour tester des fragments de code. Il est facilement utilisable dans un code, mais aussi par appel direct en ligne de commande. Le module permet d'utiliser principalement 2 fonctions: timeit() ou repeat(), pour lesquels on peut spécifier le code à tester, le nombre d'itérations, une instanciation de paramètres grâce au paramètre setup et posssiblement le nombre de fois que l'on lance le chronomètre.

en ligne de commande:
```sh
python3 -m timeit -n 1000 -r 3 -s 'a = "a\tb\tc\td"' 'values = a.split("\t")' 
1000 loops, best of 3: 287 nsec per loop
```

module timeit : _test\_timeit.py_
```python
#!/usr/bin/env python3

import timeit

def sp(a):
    values = a.split("\t")

if __name__ == '__main__':
    a = "a\tb\tc\td"
    res = timeit.repeat("sp(a)", repeat=3, number=1000, globals=globals())
    print(res)
```
execution
```
./test_timeit.py
[0.0005122157745063305, 0.0005096318200230598, 0.0005084439180791378]
```
Par rapport à l'appel direct de la ligne de commande, on perd en temps d'execution (500 nsec vs 280 nsec). Dans ce cas c'est l'appel de la fonction qui est couteux. Pour éviter de prendre ce temps d'initialisation en compte, on peut faire l'appel à timeit() dans la fonction.

```python
#!/usr/bin/env python3

import timeit

def sp(a):
    snippet = 'values = a.split("\t")'
    res = timeit.repeat(snippet, repeat=3, number=1000, globals=locals())
    print(res)

if __name__ == '__main__':
    a = "a\tb\tc\td"
    sp(a)
```
execution
```
./test_timeit2.py
[0.00037665385752916336, 0.0003682738170027733, 0.0003675050102174282]
```



https://docs.python.org/fr/3/library/time.html 
https://docs.python.org/fr/3/library/timeit.html 


### Calculer l'empreinte mémoire

Tester l'empreinte mémoire du code:

### Décorators

</pre>
