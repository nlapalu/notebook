<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>Python scientifique - session 1</title>
	<link rel="stylesheet" href="../../assets/css/reveal/reveal.css">
	<link rel="stylesheet" href="../../assets/css/reveal/theme/white.css">
	<link rel="stylesheet" href="../../assets/css/highlight-hybrid.css">
	<link rel="stylesheet" href="../../assets/css/slideshow.css">
	<style>
	</style>
	<!--  -->
</head>
<body>
	<div class="reveal">
		<div class="slides">
			<section data-markdown
			data-separator="(^#HSLIDE$|^#HSLIDE\?.*)"
			data-separator-vertical="(^#VSLIDE$|^#VSLIDE\?.*)"
			data-separator-notes="^Presentation note:"
			data-charset="utf-8">
			<script type="text/template">
				#HSLIDE

# Python scientifique ...
#HSLIDE

## Introduction
blbla plusieurs session 1 

#HSLIDE

## Execution du code temps/mémoire
#VSLIDE

### Calculer le temps d'éxecution
Si vous êtes sous linux et que vous souhaitez simplement tester le temps d&#39;execution d&#39;un script, le plus simple est d&#39;utiliser la commande system `time`.

*time.py:*

```python
#!/usr/bin/env python3

import time
time.sleep(5)
```
execution:

```sh
time ./time.py

real    0m5.050s
user    0m0.036s
sys     0m0.008s
```
Pour un affichage plus complet:

```sh
/usr/bin/time -v ./time.py
```
Si vous souhaitez mesurer le temps d&#39;execution de seulement une partie de votre code, il existe plusieurs modules qui vous permettront de faire cela. Néanmoins, ils ne vous permettront pas tous de pouvoir controler finement le vrai temps d&#39;execution.

module time: *time.py*

```python
#!/usr/bin/env python3

import time
# timing with system date
start = time.time()
print(start)
time.sleep(5)
print("{} sec".format(time.time()-start))
# timing with counter
start = time.perf_counter()
time.sleep(5)
print(start)
print("{} sec".format(time.perf_counter()-start))
# timing with execution time without sleep time
start = time.process_time()
print(start)
time.sleep(5)
print("{} sec".format(time.process_time()-start))
```
execution:

```
./time.py

1590570012.7908258  # temps depuis epoch, dependant system
5.005113124847412 sec
3783981.080605406 # counter
5.005108261015266 sec
0.038772806 # somme du temps system et cpu depuis du process en cours, sans le temps d'inactivité 
4.544399999999865e-05 sec
```
Pour info, `perf_counter()` et `process_time()` existent en version nanoseconds pour les executions rapides `perf_counter_ns()` et `process_time_ns()` 

Le module timeit a été pensé pour tester des fragments de code. Il est facilement utilisable dans un code, mais aussi par appel direct en ligne de commande. Le module permet d&#39;utiliser principalement 2 fonctions: timeit() ou repeat(), pour lesquels on peut spécifier le code à tester, le nombre d&#39;itérations, une instanciation de paramètres grâce au paramètre setup et posssiblement le nombre de fois que l&#39;on lance le chronomètre.

en ligne de commande:

```sh
python3 -m timeit -n 1000 -r 3 -s 'a = "a\tb\tc\td"' 'values = a.split("\t")' 
1000 loops, best of 3: 287 nsec per loop
```
module timeit : _test_timeit.py_

```python
#!/usr/bin/env python3

import timeit

def sp(a):
    values = a.split("\t")

if __name__ == '__main__':
    a = "a\tb\tc\td"
    res = timeit.repeat("sp(a)", repeat=3, number=1000, globals=globals())
    print(res)
```
execution

```
./test_timeit.py
[0.0005122157745063305, 0.0005096318200230598, 0.0005084439180791378]
```
https://docs.python.org/fr/3/library/time.html 
https://docs.python.org/fr/3/library/timeit.html 

#VSLIDE

### Calculer l'empreinte mémoire
Tester l&#39;empreinte mémoire du code:

#VSLIDE

### Décorators

			</script>
		</section>
	</div>
</div>

<script src="../../assets/js/reveal/reveal.js"></script>
<script src="../../assets/js/reveal/lib/head.min.js"></script>
<script src="../../assets/js/jquery.js"></script>
<script>
Reveal.initialize({
	embedded: true,
	margin: 0.0,
	showNotes: false,
	transition: 'slide',
	autoSlide: 0,
	loop: false,
	center: true,
	rtl: false,
	shuffle: false,
	mouseWheel: false,
	history: true,

	// disabled for now
	// math: {
	// 	mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
	// 	config: 'TeX-AMS_HTML-full'
	// },

	dependencies: [
		{ src: "../../assets/js/reveal/plugin/markdown/marked.js"},
		{ src: "../../assets/js/reveal/plugin/markdown/markdown.js"},
		{ src: "../../assets/js/reveal/plugin/notes/notes.js"},
		// { src: "../../assets/js/reveal/plugin/math/math.js", async: true }
		{ src: "../../assets/js/reveal/plugin/highlight/highlight.js", async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
	]
});

Reveal.configure({
	keyboard: {
		67: function() { // bind "s" key to "select" code block content

		var currentSlide = Reveal.getCurrentSlide();
		var preBlock = $(currentSlide).find("pre");

		if(preBlock.length > 0) {

			if (window.getSelection) {
				var range = document.createRange();
				range.selectNodeContents(preBlock[0]);
				var selection = window.getSelection();
				selection.removeAllRanges();
				selection.addRange(range);
			}
		}
	}
}
});

</script>

</body>
</html>
