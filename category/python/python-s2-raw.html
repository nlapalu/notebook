<pre>

# POO Python suite

## Introduction

Maintenant que nous avons abordé la POO par des exemples simples, nous allons pouvoir rajouter quelques notions plus complexes qui mettent en avant l'intérêt de l'approche objet. De la même façon que pour l'atelier précédent, nous allons extraire du code de logiciel, qui nous servira de support au explication. 

## Encapsulation: public, privé, protected et convention de nommage

Nous allons tout d'abord aborder la notion d'encapsulation, qui repose sur le fait d'authoriser l'accès à des attributs ou des méthodes dans des situations particulières. Ainsi, un attribut de type privé ne sera accessible que par la classe qui possède l'attribut, dans le cas de protégé l'attribut sera aussi accessible par les classes filles (héritage) et dans le cas publique, il n'y a pas de restriction. En python pour différencier les 3 types on utilise les \_. Ainsi on ajoute 2 \_ pour le type privé, 1 \_ pour protégé. Il n'y a rien à faire dans le cas publique.
Dans le cas de Python, il est important de comprendre que l'encapsulation n'est pas quelque-chose d'important par rapport à l'esprit du langage qui se veut simple. Ainsi, il n'y a pas de mécanisme fort d'encapsulation, ni de pratique commune, chacun peux implementer des fonctionnements différents.

Voici un exemple d'une classe `Network` de la biopython ([ici](https://github.com/biopython/biopython/blob/master/Bio/Pathway/__init__.py)). Nous allons utiliser ce code pour visualiser différents mécanismes possibles.

**Implementation initiale:**

```python
class System(object):
    """Abstraction for a collection of reactions.
    This class is used in the Bio.Pathway framework to represent an arbitrary
    collection of reactions without explicitly defined links.
    Attributes:
     - None
    """

    def __init__(self, reactions=()):
        """Initialize a new System object."""
        self.__reactions = set(reactions)

    def __repr__(self):
        """Return a debugging string representation of self."""
        return "System(" + ",".join(map(repr, self.__reactions)) + ")"

    def __str__(self):
        """Return a string representation of self."""
        return "System of " + str(len(self.__reactions)) + \
               " reactions involving " + str(len(self.species())) + \
               " species"

    def add_reaction(self, reaction):
        """Add reaction to self."""
        self.__reactions.add(reaction)

    def remove_reaction(self, reaction):
        """Remove reaction from self."""
        self.__reactions.remove(reaction)

    def reactions(self):
        """Return a list of the reactions in this system.
        Note the order is arbitrary!
        """
        # TODO - Define __lt__ so that Reactions can be sorted on Python?
        return list(self.__reactions)
```

Ainsi, si vous appelez directement l'attribut privé `__reactions`, vous obtenez une erreur:

```python
from Bio.Pathway import System, Reaction

reac1 = Reaction()
reac2 = Reaction()
syst = System((reac1, reac2))
print(syst.__reactions)

Traceback (most recent call last):
  File "./python-s2-implementation.py", line 8, in <module>
    print(syst.__reactions)
AttributeError: 'System' object has no attribute '__reactions' 
```

Vous êtes obligés, d'utiliser la méthode d'accès proposée: `reactions()`

```python
print(syst.reactions())

[Reaction({},[],None,0)]
```

Mais il faut savoir que Python triche, il renomme simplement l'attribut de façon à le masquer. Il reste accessible avec cette petite astuce:

```python
# ref instance._Class__nameAttribute
print(syst._System__reactions)

set([Reaction({},[],None,0)])
``` 

**Implementation avec accesseurs**

Nous allons faire une implementation basique avec nos propres accesseurs (=mutators)

```python
class System(object):

    def __init__(self, reactions=()):
        """Initialize a new System object."""
        self.__reactions = set(reactions)

    def get_reactions(self):
        return self.__reactions

    def set_reactions(self, reactions):
        self.__reactions = set(reactions)
```

**Implementation avec accesseurs dunder**

Nous allons remplacer nos accesseurs "maison" par des méthodes dunder. Cette implementation qui n'a pas vraiement d'intérêt, permet de comprendre que l'accès ou la modification des valeurs des attributs d'objet se fait à travers des méthodes dunder. On va pouvoir modifier le comportement de ces méthodes en autorisant par exemple l'accès aux attributs privés. On va ainsi garder la convention de nommage double \_ pour spécifier le type privé, mais néanmoins pouvoir accéder aux données.

```python
class System(object):

    def __init__(self, reactions=()):
        """Initialize a new System object."""
        self.__reactions = set(reactions)

    def __getattr__(self, name):
        if name.startswith("__"):
            # get private attribute
            return self.__dict__["".join(["_",self.__class__.__name__,name])]
        else:
            return self.__dict__[name]

    def __setattr__(self, name, value):
        if name.startswith("__"):
            # set private attribute
            self.__dict__["".join(["_",self.__class__.__name__,name])]=value
        else:
            self.__dict__[name]=value
```

**Implementation avec décorateurs**

Pour finir, je vous propose de voir une implémenation avec un décorateur, particularité du langage Python. Nous reviendrons dans un atelier futur sur les décorateurs, pour l'instant vous pouvez simplement retenir qu'un décorateur est une fonction qui va permettre d'executer des pré/post traitements lorsqu'il est associé à une autre fonction/méthode. Dans ce cas nous allons utiliser des décorateurs déjà fournis par le langage Python, "Property", à savoir qu'il est tout à fait possible de coder ses propores décorateurs. Pour plus d'info un très bon blog avec de très bons liens et ressources [ici](http://gillesfabio.com/blog/2010/12/16/python-et-les-decorateurs/)

```python
class System(object):

    def __init__(self, reactions=()):
        """Initialize a new System object."""
        self.__reactions = set(reactions)

    @property
    def reactions(self):
        return self.__reactions

    @reactions.setter
    def reactions(self, reactions=()):
        self.__reactions = set(reactions)

reac1 = Reaction("1")
reac2 = Reaction("1")
syst = System((reac1, reac2))
print(syst.reactions)
syst.reactions = (reac1, Reaction("2"))
print(syst.reactions)
```

**Implementation avec property()**

L'implementation des décorateurs vu au dessus est inspiré de la primitive `property()` `(property(fget=None, fset=None, fdel=None, doc=None))`qui peut aussi permettre d'implémenter un accès aux données:

```python
class System(object):

    def __init__(self, reactions=()):
        """Initialize a new System object."""
        self.__reactions = set(reactions)

    def __get_reactions(self):
        return self.__reactions

    def __set_reactions(self, reactions=()):
        self.__reactions = set(reactions)

    reactions=property(__get_reactions, __set_reactions)

reac1 = Reaction("1")
reac2 = Reaction("1")
syst = System((reac1, reac2))
print(syst.reactions)
syst.reactions = (reac1, Reaction("2"))
print(syst.reactions)
```

Nous avons vu ici le mécanisme de decorateur et de property pour contrôler l'accès aux données. Attention, il est recommandé d'éviter ce genre d'implementation si il y a nécéssité d'accès important et récurrent aux données. 

Si nous résumons cette partie, il faut garder à l'esprit que la notion d'encapsulation en python n'est pas aussi restrictive que dans d'autres langages comme Java par exemple. Elle est surtout utilisée pour vous aider à structurer votre code en choisissant d'exposer plus ou moins certaines parties du code. L'encapsulation se fait par convention de nommage et il est possible d'utiliser plusieurs mécanismes pour accéder aux données ou méthodes.

 
## Attributs de Classe, methodes de Classe, méthodes statiques

**Attributs de Classe**

Les attributs de classe sont des attributs liés au type de la classe et non à une instance de celle-ci. Reprenons notre classe `System` et rajoutons un attribut de classe qui va permettre de connaitre le nombre d'instance en cours de la classe. Celui se rajoute directement sous la déclaration de la class hors de la méthode d'initialisation. 

```python
class System(object):

    nbSystems = 0

    def __init__(self, reactions=()):
        """Initialize a new System object."""
        self.__reactions = set(reactions)
        self.__class__.nbSystems += 1

    def __del__(self):
        self.__class__.nbSystems -= 1


if __name__ == "__main__":

    reac1 = Reaction()
    reac2 = Reaction()
    syst = System((reac1, reac2))
    print(System.nbSystems)
    syst = System([reac1])
    print(System.nbSystems)
    syst2 = System([reac1])
    print(System.nbSystems)
    del(syst)
    print(System.nbSystems)

1
1
2
1
```

A chaque fois qu'un nouvel objet est initialisé, le compteur `nbSystems` est incrémenté de 1. De même si un objet est supprimé, le compteur décroit de 1. 


**Méthodes de Classe - Méthodes statiques**

Il est possible aussi d'avoir des méthodes sur des classes qui sont utilisables s'en avoir instancié un objet au préalable. Il y a les méthodes de classe, dont le rôle est en général de permettre l'instanciation d'objet différemment que par l'instanciation normale. Ces méthodes ont simplement besoin d'avoir en argument le type de la classe. Il exsite aussi les méthodes statiques, qui elles n'ont aucun pré-requis et peuvent directement appelées depuis le type de la classe. Elles sont souvent utilisées pour faire des classes dites utilitaires.

Modifions notre classe System en créant une méthode de classe qui va nous permettre de générer un nouveau `System` en réunissant une liste de `System` passée en arguments. Simultanément, nous allons implémenter une méthode statique qui va nous permettre d'avoir la somme des réactions présents dans une liste de `System`.  

```python
class System(object):

    nbSystems = 0

    def __init__(self, reactions=()):
        """Initialize a new System object."""
        self.__reactions = set(reactions)
        self.__class__.nbSystems += 1

    def __del__(self):
        self.__class__.nbSystems -= 1

    @property
    def reactions(self):
        return self.__reactions

    @reactions.setter
    def reactions(self, reactions=()):
        self.__reactions = set(reactions)

    @classmethod
    def merge_systems(cls,systems=[]):

        lreactions = []
        for sys in systems:
            lreactions.extend(sys.reactions)

        return cls(set(lreactions))

    @staticmethod
    def count_reactions(systems=[]):

        return sum([len(syst.reactions) for syst in systems])

if __name__ == "__main__":

   syst = System(("reac1", "reac2"))
   print(System.nbSystems)
   print(syst.reactions)
   syst2 = System(("reac1", "reac3"))
   print(System.nbSystems)
   print(syst2.reactions)
   syst3 = System.merge_systems([syst,syst2])
   print(System.nbSystems)
   print(syst3.reactions)
   print(System.count_reactions([syst,syst2,syst3]))


1
set(['reac1', 'reac2'])
2
set(['reac1', 'reac3'])
3
set(['reac1', 'reac2', 'reac3'])
7
```
Pour info, il est possible de ne pas utiliser de decorator pour spécifier le type "classmethod" ou "staticmethod" en utilisant des primitives:

```python
    def merge_systems(cls,systems=[]):

        lreactions = []
        for sys in systems:
            lreactions.extend(sys.reactions)

        return cls(set(lreactions))
    merge_systems = classmethod(merge_systems)

    def count_reactions(systems=[]):

        return sum([len(syst.reactions) for syst in systems])
    count_reactions = staticmethod(count_reactions)

```


## Polymorphisme

## Héritage

## Abstraction, Interfaces

## Implémentation

## Retour sur l'atelier

## Références

[encapsulation](https://openclassrooms.com/fr/courses/4302126-decouvrez-la-programmation-orientee-objet-avec-python/4313211-comprenez-lencapsulation)
[properties-decorateurs](https://www.python-course.eu/python3_properties.php)
[decorateurs](http://gillesfabio.com/blog/2010/12/16/python-et-les-decorateurs/)
[decorateurs](https://wiki.python.org/moin/PythonDecoratorLibrary)
[decorateurs](https://realpython.com/primer-on-python-decorators/)
</pre>
